<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
<head>
    <!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5P98');</script>
<!-- End Google Tag Manager -->
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Functions - Arend Theorem Prover</title>
<meta name="description" content="The Arend Theorem Prover">



<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arend Theorem Prover">
<meta property="og:title" content="Functions">
<meta property="og:url" content="http://localhost:4000/documentation/language-reference/definitions/functions.html">


  <meta property="og:description" content="The Arend Theorem Prover">












<link rel="canonical" href="http://localhost:4000/documentation/language-reference/definitions/functions.html">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arend Theorem Prover Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script type="text/javascript">
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    
</head>

<body class="layout--single">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5P98"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

<!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->



<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Arend Theorem Prover
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/documentation"
                
                
              >Documentation</a>
            </li><li class="masthead__menu-item">
              <a
                href="/documentation/getting-started/download"
                
                
              >Download</a>
            </li><li class="masthead__menu-item">
              <a
                href="/arend-lib"
                
                
              >Arend Library</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


<div class="initial-content">
    



<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
    
      



<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>

  
  
  
  

  
  
  

  <ul class="nav__items">
    
      <li>
        
          
          

          <a href="/documentation/getting-started"><span class="nav__sub-title">Getting Started</span></a>
        

        
        <ul>
          
            
            

            

            <li><a href="/documentation/getting-started/arend-features" class="">Arend features</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/getting-started/download" class="">Downloading Arend</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/getting-started/started" class="">Creating first project</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/getting-started/libraries" class="">Arend libraries</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/getting-started/intellij-arend-tutorial" class="">Short tutorial</a></li>

            
            
            
          
        </ul>
        
      </li>
    
      <li>
        
          
          

          <a href="/documentation/tutorial"><span class="nav__sub-title">Tutorial</span></a>
        

        
        <ul>
          
            
            

            

            <li><a href="/documentation/tutorial/PartI" class="">Part I: Dependent Types</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/tutorial/PartII" class="">Part II: Homotopy Type Theory</a></li>

            
            
            
          
        </ul>
        
      </li>
    
      <li>
        
          
          

          <a href="/documentation/standard-tactics"><span class="nav__sub-title">Standard metas</span></a>
        

        
        <ul>
          
            
            

            

            <li><a href="/documentation/standard-tactics/meta" class="">Unclassified metas</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/standard-tactics/paths-meta" class="">Paths metas</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/standard-tactics/function-meta" class="">Functional metas</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/standard-tactics/algebra-meta" class="">Algebraic metas</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/standard-tactics/logic-meta" class="">Logical metas</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/standard-tactics/debug-meta" class="">Debugging metas</a></li>

            
            
            
          
        </ul>
        
      </li>
    
      <li>
        
          
          

          <a href="/documentation/language-reference"><span class="nav__sub-title">Language Reference</span></a>
        

        
        <ul>
          
            
            

            

            <li><a href="/documentation/language-reference/lexical-structure" class="">Lexical structure</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/language-reference/definitions" class="">Definitions</a></li>

            
            
            
              
                
                

                

                <li><a href="/documentation/language-reference/definitions/modules" class="">&nbsp;&nbsp;&nbsp;&nbsp;Modules</a></li>
              
                
                

                

                <li><a href="/documentation/language-reference/definitions/parameters" class="">&nbsp;&nbsp;&nbsp;&nbsp;Parameters</a></li>
              
                
                

                

                <li><a href="/documentation/language-reference/definitions/functions" class="active">&nbsp;&nbsp;&nbsp;&nbsp;Functions</a></li>
              
                
                

                

                <li><a href="/documentation/language-reference/definitions/types" class="">&nbsp;&nbsp;&nbsp;&nbsp;Type synonyms</a></li>
              
                
                

                

                <li><a href="/documentation/language-reference/definitions/data" class="">&nbsp;&nbsp;&nbsp;&nbsp;Data</a></li>
              
                
                

                

                <li><a href="/documentation/language-reference/definitions/hits" class="">&nbsp;&nbsp;&nbsp;&nbsp;Higher inductive types</a></li>
              
                
                

                

                <li><a href="/documentation/language-reference/definitions/records" class="">&nbsp;&nbsp;&nbsp;&nbsp;Records</a></li>
              
                
                

                

                <li><a href="/documentation/language-reference/definitions/classes" class="">&nbsp;&nbsp;&nbsp;&nbsp;Classes</a></li>
              
                
                

                

                <li><a href="/documentation/language-reference/definitions/metas" class="">&nbsp;&nbsp;&nbsp;&nbsp;Meta definitions</a></li>
              
                
                

                

                <li><a href="/documentation/language-reference/definitions/coercion" class="">&nbsp;&nbsp;&nbsp;&nbsp;Coercion</a></li>
              
                
                

                

                <li><a href="/documentation/language-reference/definitions/level" class="">&nbsp;&nbsp;&nbsp;&nbsp;Level</a></li>
              
            
          
            
            

            

            <li><a href="/documentation/language-reference/expressions" class="">Expressions</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/language-reference/prelude" class="">Prelude</a></li>

            
            
            
          
        </ul>
        
      </li>
    
      <li>
        
          
          

          <a href="/documentation/plugin-manual"><span class="nav__sub-title">Plugin reference</span></a>
        

        
        <ul>
          
            
            

            

            <li><a href="/documentation/plugin-manual/editor-features" class="">Editor features</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/plugin-manual/navigating" class="">Navigation</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/plugin-manual/refactoring" class="">Refactoring</a></li>

            
            
            
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Functions">
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Functions
</h1>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> Functions</h4></header>
              <ul class="toc__menu"><li><a href="#non-recursive-definitions">Non-recursive definitions</a></li><li><a href="#pattern-matching">Pattern matching</a></li><li><a href="#elim">Elim</a></li><li><a href="#recursive-functions">Recursive functions</a></li><li><a href="#copattern-matching">Copattern matching</a></li><li><a href="#patterns-in-coclauses">Patterns in coclauses</a></li><li><a href="#lemmas">Lemmas</a></li><li><a href="#sfunc">\sfunc</a></li></ul>
            </nav>
          </aside>
        
        <p>Functions in Arend are functions in the mathematical sense.
They can have arbitrary arity.
In particular, constants in Arend are just functions of arity 0.
A definition of a function <span class="inl-highlight">f</span> consists of the signature of <span class="inl-highlight">f</span> followed by the body of <span class="inl-highlight">f</span>.
The full syntax of function signatures is as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> f p_1 ... p_n <span class="o">:</span> T</code></pre></div></div>

<p>where <span class="inl-highlight">f</span> is the name of the function, <span class="inl-highlight">p_1<span class="o">,</span> … p_n</span> are named <a href="parameters">parameters</a> and
<span class="inl-highlight">T</span> is the result type. In some cases specification <span class="inl-highlight"><span class="o">:</span> T</span> of the result type can be omitted depending on the 
definition of function body.</p>

<p>There are several ways to define the body of a function. These ways are described below.</p>

<h2 id="non-recursive-definitions">Non-recursive definitions</h2>

<p>A non-recursive function can be defined simply by specifying an expression for the result of the function:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> f p_1 ... p_n <span class="o">:</span> T <span class="o">=&gt;</span> e</code></pre></div></div>

<p>where <span class="inl-highlight">e</span> is an expression, which must be
of type <span class="inl-highlight">T</span> if it is specified. In such definitions the result type <span class="inl-highlight"><span class="o">:</span> T</span> can often be omitted as the typechecker 
can usually infer it from <span class="inl-highlight">e</span>.</p>

<p>For example, to define the identity function on type <span class="inl-highlight">A</span>, write the following code:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> id (x <span class="o">:</span> A) <span class="o">=&gt;</span> x</code></pre></div></div>

<p>A function with three parameters that returns the second one can be defined as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> second (x <span class="o">:</span> A) (y <span class="o">:</span> B) (z <span class="o">:</span> C) <span class="o">=&gt;</span> y</code></pre></div></div>

<p>You can explicitly specify the result types of these functions.
The definitions above are equivalent to the following definitions:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> id (x <span class="o">:</span> A) <span class="o">:</span> A <span class="o">=&gt;</span> x
<span class="k">\func</span> second (x <span class="o">:</span> A) (y <span class="o">:</span> B) (z <span class="o">:</span> C) <span class="o">:</span> B <span class="o">=&gt;</span> y</code></pre></div></div>

<p>Parameters of a function may appear in its body and in its result type.</p>

<h2 id="pattern-matching">Pattern matching</h2>

<p>Functions can be defined by pattern matching.
Let <span class="inl-highlight">D</span> be an <a href="data">inductive type</a> with constructors <span class="inl-highlight">con1</span> and <span class="inl-highlight">con2 Nat</span>.
You can define a function which maps <span class="inl-highlight">D</span> to natural numbers in such a way that <span class="inl-highlight">con1</span> is mapped to <span class="inl-highlight"><span class="n">0</span></span> and <span class="inl-highlight">con2 n</span> is mapped to <span class="inl-highlight">suc n</span>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> f (d <span class="o">:</span> D) <span class="o">:</span> Nat
  <span class="o">|</span> con1 <span class="o">=&gt;</span> <span class="n">0</span>
  <span class="o">|</span> con2 n <span class="o">=&gt;</span> suc n</code></pre></div></div>

<p>The result type of a function defined by pattern matching must be specified explicitly.
The general form of function definition by pattern matching is</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> f (x_1 <span class="o">:</span> T_1) ... (x_n <span class="o">:</span> T_n) <span class="o">:</span> R
  <span class="o">|</span> clause_1
  ...
  <span class="o">|</span> clause_k</code></pre></div></div>

<p>where each <span class="inl-highlight">clause_i</span> is of the form</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p^i_1<span class="o">,</span> ... p^i_n <span class="o">=&gt;</span> e_i</code></pre></div></div>

<p>where <span class="inl-highlight">p^i_j</span> is a pattern of type <span class="inl-highlight">T_i</span> (see below for the definition of a pattern) and <span class="inl-highlight">e_i</span> is an
expression of type <span class="inl-highlight">R[p^i_1/x_1<span class="o">,</span> … p^i_n/x_n]</span> (see <a href="../expressions">Expressions</a> for the
discussion of the substitution operation and types of expressions).
Variables <span class="inl-highlight">x_1<span class="o">,</span> … x_n</span> are not visible in expressions <span class="inl-highlight">e_i</span>.
Note that this construction requires all the variables to be matched on,
that is the number of patterns in each clause must be <span class="inl-highlight">n</span> (but see <a href="#elim">below</a> for partial pattern matching).</p>

<p>The clauses <span class="inl-highlight">clause_1<span class="o">,</span> … clause_k</span> must cover all the cases.
That is, if there is a pattern of the form <span class="inl-highlight">con p_1 … p_n</span>, where <span class="inl-highlight">con</span> is a constructor of a data type <span class="inl-highlight">D</span>,
then there must be patterns of the form <span class="inl-highlight">con’ p_1’ … p_k’</span> for all constructors <span class="inl-highlight">con’</span> of <span class="inl-highlight">D</span>.</p>

<p>Pattern matching on constructors <span class="inl-highlight">left</span> and <span class="inl-highlight">right</span> of the <a href="../prelude">interval type</a> <span class="inl-highlight">I</span> is not allowed.
For example, the definition <span class="inl-highlight"><span class="k">\func</span> f (i <span class="o">:</span> I) <span class="o">:</span> Nat <span class="o">|</span> left <span class="o">=&gt;</span> <span class="n">0</span> <span class="o">|</span> right <span class="o">=&gt;</span> <span class="n">1</span></span> is not valid.</p>

<p>If some of the parameters of <span class="inl-highlight">f</span> are implicit, corresponding patterns must be either omitted or specified explicitly by surrounding them in <span class="inl-highlight">{ }</span>.</p>

<p>The definition above can be equivalently written using the keyword <span class="inl-highlight"><span class="k">\with</span></span>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> f p_1 ... p_n <span class="o">:</span> R <span class="k">\with</span> { <span class="o">|</span> clause_1 ... <span class="o">|</span> clause_k }</code></pre></div></div>

<p>A <em>pattern</em> of type <span class="inl-highlight">T</span> can have one of the following forms:</p>

<ul>
  <li>A variable. If a variable <span class="inl-highlight">x</span> appears as a subpattern of <span class="inl-highlight">p_i</span> in a clause <span class="inl-highlight"><span class="o">|</span> p_1 … p_i … <span class="o">=&gt;</span> e</span>, 
it can be used in <span class="inl-highlight">e</span> and it will have type <span class="inl-highlight">T</span>. If this variable is not used anywhere, its name can be replaced with <span class="inl-highlight"><span class="u">_</span></span>.</li>
  <li><span class="inl-highlight">con s_1 … s_m</span>, where <span class="inl-highlight">con (y_1 <span class="o">:</span> A_1) … (y_m <span class="o">:</span> A_m)</span> is a constructor of a data type <span class="inl-highlight">D</span> and <span class="inl-highlight">s_1 … s_m</span> are patterns.
In this case, <span class="inl-highlight">T</span> must be equal to <span class="inl-highlight">D</span> and pattern <span class="inl-highlight">s_i</span> must have type <span class="inl-highlight">A_i[s_1/y_1<span class="o">,</span> … s_{i-1}/y_{i-1}]</span>.
If some of the parameters of <span class="inl-highlight">con</span> are implicit, corresponding patterns must either be omitted or enclosed in <span class="inl-highlight">{ }</span>.</li>
  <li><span class="inl-highlight">(s_1<span class="o">,</span> … s_m)</span>, where <span class="inl-highlight">s_1 … s_m</span> are patterns.
In this case, <span class="inl-highlight">T</span> must be either a <a href="../expressions/sigma">Sigma type</a> with parameters <span class="inl-highlight">(y_1 <span class="o">:</span> A_1) … (y_m <span class="o">:</span> A_m)</span> or a <a href="classes">class</a> (or a <a href="records">record</a>) with fields <span class="inl-highlight">y_1 <span class="o">:</span> A_1<span class="o">,</span> … y_m <span class="o">:</span> A_m</span>.
The pattern <span class="inl-highlight">s_i</span> must have type <span class="inl-highlight">A_i[s_1/y_1<span class="o">,</span> … s_{i-1}/y_{i-1}]</span>.
If <span class="inl-highlight">m</span> equals to 0, then <span class="inl-highlight">T</span> may also be a data type without constructors.
In this case, the right hand side <span class="inl-highlight"><span class="o">=&gt;</span> e_i</span> of the clause in which such a pattern appears must be omitted.</li>
</ul>

<p>Also, a constructor or a tuple pattern may be an <em>as-pattern</em>.
This means that there might be an expressions of the form <span class="inl-highlight"><span class="k">\as</span> x <span class="o">:</span> E</span> after the pattern, where <span class="inl-highlight">x</span> is a variable and <span class="inl-highlight">E</span> is its type which can be omitted.
Then <span class="inl-highlight">x</span> is equivalent to this pattern.</p>

<p>Now, let us discuss how expressions of the form <span class="inl-highlight">f a_1 … a_n</span> evaluate (see <a href="../expressions#evaluation">Expressions</a> for the definition of the reduction and evaluation relations).
Let <span class="inl-highlight">E</span> be equal to <span class="inl-highlight">f a_1 … a_n</span>.
To reduce this expression, we first evaluate expressions <span class="inl-highlight">a_1<span class="o">,</span> … a_n</span> and match them with the patterns in the definition of <span class="inl-highlight">f</span> left to right, top to bottom.
If all patterns <span class="inl-highlight">p^i_1<span class="o">,</span> … p^i_n</span> matches with <span class="inl-highlight">a_1<span class="o">,</span> … a_n</span> for some <em>i</em>, then <span class="inl-highlight">E</span> reduces to <span class="inl-highlight">e_i[b_1/y_1<span class="o">,</span> … b_k/y_k]</span>,
where <span class="inl-highlight">y_1<span class="o">,</span> … y_k</span> are variables that appear in <span class="inl-highlight">p^i_1<span class="o">,</span> … p^i_n</span> and <span class="inl-highlight">b_1<span class="o">,</span> … b_k</span> are subexpressions of <span class="inl-highlight">a_1<span class="o">,</span> … a_n</span> corresponding to these variables.
If some argument cannot be matched with a pattern <span class="inl-highlight">con s_1 … s_m</span> because it is of the form <span class="inl-highlight">con’ …</span> for some constructor <span class="inl-highlight">con’</span> different from <span class="inl-highlight">con</span>,
then the evaluator skips the clause with this patterns and tries the next one.
If some argument cannot be matched with a pattern because it is not a constructor, then <span class="inl-highlight">E</span> does not reduce.
If none of the clauses match with arguments, then <span class="inl-highlight">E</span> also does not reduce.
Variables and patterns of the form <span class="inl-highlight">(s_1<span class="o">,</span> … s_m)</span> match with any expression.</p>

<p>Let us consider an example.
Let <span class="inl-highlight">B</span> be a data type with two constructors <span class="inl-highlight">T</span> and <span class="inl-highlight">F</span>.
Consider the following function:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> g (b b' <span class="o">:</span> B) <span class="o">:</span> Nat
  <span class="o">|</span> T<span class="o">,</span> <span class="u">_</span> <span class="o">=&gt;</span> <span class="n">0</span>
  <span class="o">|</span> <span class="u">_</span><span class="o">,</span> T <span class="o">=&gt;</span> <span class="n">1</span>
  <span class="o">|</span> <span class="u">_</span><span class="o">,</span> <span class="u">_</span> <span class="o">=&gt;</span> <span class="n">2</span></code></pre></div></div>

<p>Let <span class="inl-highlight">x</span> be a variable and let <span class="inl-highlight">e</span> be an arbitrary expression.
If the first argument of <span class="inl-highlight">g a_1 a_2</span> is <span class="inl-highlight">T</span>, then the expression reduces to <span class="inl-highlight"><span class="n">0</span></span>, if it is <span class="inl-highlight">x</span>,
then the expression does not reduce since the first pattern fails to match with <span class="inl-highlight">x</span>.
If the first argument is <span class="inl-highlight">F</span>, then the evaluator tries to match the second argument:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g T e <span class="o">=&gt;</span> <span class="n">0</span>
g x e <span class="c">-- does not reduce
</span>
g F T <span class="o">=&gt;</span> <span class="n">1</span>
g F F <span class="o">=&gt;</span> <span class="n">2</span>
g F x <span class="c">-- does not reduce</span></code></pre></div></div>

<p>Note that patterns are matched left to right, top to bottom and not the other way around.
This means that even if a funcall matches the first clause, it may not evaluate.
For example, consider the following definition:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> <span class="k">\infix</span> <span class="n">4</span> &lt; (n m <span class="o">:</span> Nat) <span class="o">:</span> Bool
  <span class="o">|</span> <span class="u">_</span><span class="o">,</span> <span class="n">0</span> <span class="o">=&gt;</span> false
  <span class="o">|</span> <span class="n">0</span><span class="o">,</span> suc <span class="u">_</span> <span class="o">=&gt;</span> true
  <span class="o">|</span> suc n<span class="o">,</span> suc m <span class="o">=&gt;</span> n &lt; m</code></pre></div></div>

<p>The funcall <span class="inl-highlight">n &lt; <span class="n">0</span></span> does not evaluate since it matches the first argument first, but funcalls <span class="inl-highlight"><span class="n">0</span> &lt; <span class="n">0</span></span> and <span class="inl-highlight">suc n &lt; <span class="n">0</span></span> both evaluate to <span class="inl-highlight">false</span>.</p>

<p>Sometimes you need to write a clause in which one of the parameters is a data type without constructors.
You can write pattern <span class="inl-highlight">()</span> which is called in this case <em>the absurd pattern</em>.
In this case, you must omit the right hand side of the clause.
For example, to define a function from the empty data type you can write:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\data</span> Empty

<span class="k">\func</span> absurd {A <span class="o">:</span> <span class="kt">\Type</span>} (e <span class="o">:</span> Empty) <span class="o">:</span> A
  <span class="o">|</span> ()</code></pre></div></div>

<p>You can often (but not always) omit the clause with an absurd pattern completely.
For example, you can define function <span class="inl-highlight">absurd</span> as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> absurd {A <span class="o">:</span> <span class="kt">\Type</span>} (e <span class="o">:</span> Empty) <span class="o">:</span> A</code></pre></div></div>

<p>Finally, the type <span class="inl-highlight">con1 <span class="o">=</span> con2</span> is considered empty if <span class="inl-highlight">con1</span> and <span class="inl-highlight">con2</span> are disjoint constructors of some data type.</p>

<p>If the constructor is infix, then it can be used in the infix form in a pattern.
For example, functions <span class="inl-highlight">tail</span> and <span class="inl-highlight">tail’</span> below are equivalent:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\data</span> List (A <span class="o">:</span> <span class="kt">\Type</span>) <span class="o">|</span> nil <span class="o">|</span> <span class="k">\infixr</span> <span class="n">5</span> <span class="o">:</span><span class="o">:</span> A (List A)

<span class="k">\func</span> tail {A <span class="o">:</span> <span class="kt">\Type</span>} (l <span class="o">:</span> List A) <span class="o">:</span> List A
  <span class="o">|</span> nil <span class="o">=&gt;</span> nil
  <span class="o">|</span> <span class="o">:</span><span class="o">:</span> <span class="u">_</span> l <span class="o">=&gt;</span> l

<span class="k">\func</span> tail' {A <span class="o">:</span> <span class="kt">\Type</span>} (l <span class="o">:</span> List A) <span class="o">:</span> List A
  <span class="o">|</span> nil <span class="o">=&gt;</span> nil
  <span class="o">|</span> <span class="u">_</span> <span class="o">:</span><span class="o">:</span> l <span class="o">=&gt;</span> l</code></pre></div></div>

<h2 id="elim">Elim</h2>

<p>It is often true that one only needs to pattern match on a single parameter of a function (or a few parameters), but the function has much more parameters.
Then we need to repeat parameters on which we do not pattern match in each clause, which is inconvenient.
In this case, we can use the <span class="inl-highlight"><span class="k">\elim</span></span> construction:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> f (x_1 <span class="o">:</span> A_1) ... (x_n <span class="o">:</span> A_n) <span class="o">:</span> R <span class="k">\elim</span> x_{i_1}<span class="o">,</span> ... x_{i_m}
  <span class="o">|</span> p^1_1<span class="o">,</span> ... p^1_m <span class="o">=&gt;</span> e_1
  ...
  <span class="o">|</span> p^k_1<span class="o">,</span> ... p^k_m <span class="o">=&gt;</span> e_k</code></pre></div></div>

<p>where i_1, … i_m are integers such that 1 ≤ i_1 &lt; … &lt; i_m ≤ n.
In this case, parameters <span class="inl-highlight">x_{i_1}<span class="o">,</span> … x_{i_m}</span> are <em>eliminated</em> and are not visible in expressions <span class="inl-highlight">e_1<span class="o">,</span> … e_k</span>.
Other parameters of <span class="inl-highlight">f</span> are still visible in these expressions.
Note that it does not matter whether a parameter <span class="inl-highlight">x_i</span> is explicit or implicit when it is eliminated, the corresponding pattern is always explicit.</p>

<p>As an example, consider the following function which chooses one of its arguments depending on the value of its other argument:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> if (b <span class="o">:</span> B) (t e <span class="o">:</span> X) <span class="o">:</span> X <span class="k">\elim</span> b
  <span class="o">|</span> T <span class="o">=&gt;</span> t
  <span class="o">|</span> F <span class="o">=&gt;</span> e</code></pre></div></div>

<h2 id="recursive-functions">Recursive functions</h2>

<p>Functions defined by pattern matching can be recursive.
That is, if <span class="inl-highlight">f</span> is a function as described above, then a reference to <span class="inl-highlight">f</span> may occur inside expressions <span class="inl-highlight">e_1<span class="o">,</span> … e_k</span>.
Every function in Arend is a total function.
Thus, not every recursive definition is allowed.
In order for such a definition to be valid, the recursion must be <em>structural</em>.
This means that in a definition of <span class="inl-highlight">f</span> by pattern matching the arguments to recursive calls of <span class="inl-highlight">f</span> must be
subpatterns of the patterns for the arguments of <span class="inl-highlight">f</span>.</p>

<p>Functions can also be mutually recursive.
That is, we can have several functions which refer to each other.
In this case, there must be a linear order on the set of these functions <span class="inl-highlight">f_1<span class="o">,</span> … f_n</span> such that the signature of <span class="inl-highlight">f_i</span> refers only to previous functions.
The bodies of the functions may refer to each other as long as the whole recursive system is structural.</p>

<h2 id="copattern-matching">Copattern matching</h2>

<p>If the result type of a function is a <a href="records">record</a> or a <a href="classes">class</a>,
then a function can also be defined by <em>copattern matching</em>, which has the following syntax:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> f (x_1 <span class="o">:</span> A_1) ... (x_n <span class="o">:</span> A_n) <span class="o">:</span> C <span class="k">\cowith</span>
  <span class="o">|</span> coclause_1
  ...
  <span class="o">|</span> coclause_k</code></pre></div></div>

<p>where a <em>coclause</em> is a pair consisting of a field <span class="inl-highlight">g</span> of <span class="inl-highlight">C</span> and an expression <span class="inl-highlight">e</span> written <span class="inl-highlight">g <span class="o">=&gt;</span> e</span>.
Such a function has the same semantics as a definition of an instance, that is it is equivalent to the following definition:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> f (x_1 <span class="o">:</span> A_1) ... (x_n <span class="o">:</span> A_n) <span class="o">=&gt;</span> <span class="k">\new</span> C {
  <span class="o">|</span> coclause_1
  ...
  <span class="o">|</span> coclause_k
}</code></pre></div></div>

<p>See <a href="../expressions/class-ext">Class extensions</a> for the description of the involved constructions.</p>

<h2 id="patterns-in-coclauses">Patterns in coclauses</h2>

<p>It is possible to implement a field using pattern matching:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> f (x_1 <span class="o">:</span> A_1) ... (x_n <span class="o">:</span> A_n) <span class="o">:</span> C <span class="k">\cowith</span>
  ...
  <span class="o">|</span> field (y_1 <span class="o">:</span> B_1) ... (y_k <span class="o">:</span> B_k) <span class="o">:</span> D <span class="k">\with</span> {
    <span class="o">|</span> clause_1
    ...
    <span class="o">|</span> clause_m
  }
  ...</code></pre></div></div>

<p>Keyword <span class="inl-highlight"><span class="k">\with</span></span> can be replaced with <span class="inl-highlight"><span class="k">\elim</span></span> as usual.
Currently, clauses in such an implementation cannot refer to parameters of the function.</p>

<h2 id="lemmas">Lemmas</h2>

<p>A <em>lemma</em> is a function, the result type of which is a proposition and the body is considered to be a proof 
without computational content, and, thus, it does not evaluate.
To define a lemma use the keyword <span class="inl-highlight"><span class="k">\lemma</span></span> instead of <span class="inl-highlight"><span class="k">\func</span></span>.
If the result type of a lemma does not belong to <span class="inl-highlight"><span class="kt">\Prop</span></span>, but is provably a proposition, you can use the keywords <a href="level#level-of-a-type">\level</a> to define a lemma with this result type.
The fact that lemmas do not evaluate may greatly improve performance of typechecking if their proofs are too lengthy.</p>

<p>An <em>axiom</em> is a lemma without a body.
Axioms are defined with the keyword <span class="inl-highlight"><span class="k">\axiom</span></span>.</p>

<h2 id="sfunc">\sfunc</h2>

<p>Functions defined as <span class="inl-highlight"><span class="k">\sfunc</span></span> do not evaluate just as lemmas, but it is possible to evaluate such functions by using keyword <span class="inl-highlight"><span class="k">\eval</span></span>.
Let <code class="language-plaintext highlighter-rouge">f</code> be an ordinary function and let <span class="inl-highlight">a_1<span class="o">,</span> … a_n</span> be arguments such that expression <span class="inl-highlight">f a_1 … a_n</span> evaluates to <code class="language-plaintext highlighter-rouge">e</code>.
If <code class="language-plaintext highlighter-rouge">f</code> is defined as <span class="inl-highlight"><span class="k">\sfunc</span></span>, then this expression won’t evaluate, but expression <span class="inl-highlight"><span class="k">\eval</span> f a_1 … a_n</span> evaluates to <code class="language-plaintext highlighter-rouge">e</code>.
To prove that <span class="inl-highlight">f a_1 … a_n</span> equals to <span class="inl-highlight"><span class="k">\eval</span> f a_1 … a_n</span>, you can use keyword <span class="inl-highlight"><span class="k">\peval</span></span>.
Expression <span class="inl-highlight"><span class="k">\peval</span> f a_1 … a_n</span> has type <span class="inl-highlight">f a_1 … a_n <span class="o">=</span> <span class="k">\eval</span> f a_1 … a_n</span>.</p>

<p>Note that it is necessary to use <span class="inl-highlight"><span class="k">\sfunc</span></span> <a href="level#squashed-data-types">in some cases</a>.</p>

        
      </section>

      <footer class="page__meta">
        
        


        
      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

</div>



<div id="footer" class="page__footer">
    <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://github.com/JetBrains/Arend" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://twitter.com/ArendLang" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i> Twitter</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 <a href="http://localhost:4000">Arend Theorem Prover</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

    </footer>
</div>


  <script src="/assets/js/main.min.js"></script>










</body>
</html>
