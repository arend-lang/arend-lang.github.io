<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.16.4 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Functions - Arend Theorem Prover</title>
<meta name="description" content="The Arend Theorem Prover">



<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arend Theorem Prover">
<meta property="og:title" content="Functions">
<meta property="og:url" content="https://arend-lang.github.io/documentation/language-reference/definitions/functions.html">













<link rel="canonical" href="https://arend-lang.github.io/documentation/language-reference/definitions/functions.html">













<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arend Theorem Prover Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE ]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">Arend Theorem Prover</a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/about" >About</a>
            </li><li class="masthead__menu-item">
              <a href="/documentation" >Documentation</a>
            </li><li class="masthead__menu-item">
              <a href="/download" >Download</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>

  
  
  
  

  <ul class="nav__items">
    
      <li>
        
          
          

          <a href="/documentation/getting-started"><span class="nav__sub-title">Getting Started</span></a>
        

        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Language Reference</span>
        

        
        <ul>
          
            
            

            

            <li><a href="/documentation/language-reference/lexical-structure" class="">Lexical structure</a></li>

            
          
            
            

            

            <li><a href="/documentation/language-reference/definitions" class="">Definitions</a></li>

            
              
              

              

              <li><a href="/documentation/language-reference/definitions/modules" class="">&nbsp;&nbsp;&nbsp;&nbsp;Modules</a></li>
            
              
              

              

              <li><a href="/documentation/language-reference/definitions/parameters" class="">&nbsp;&nbsp;&nbsp;&nbsp;Parameters</a></li>
            
              
              

              

              <li><a href="/documentation/language-reference/definitions/functions" class="active">&nbsp;&nbsp;&nbsp;&nbsp;Functions</a></li>
            
              
              

              

              <li><a href="/documentation/language-reference/definitions/data" class="">&nbsp;&nbsp;&nbsp;&nbsp;Data</a></li>
            
              
              

              

              <li><a href="/documentation/language-reference/definitions/hits" class="">&nbsp;&nbsp;&nbsp;&nbsp;Higher inductive types</a></li>
            
              
              

              

              <li><a href="/documentation/language-reference/definitions/records" class="">&nbsp;&nbsp;&nbsp;&nbsp;Records</a></li>
            
              
              

              

              <li><a href="/documentation/language-reference/definitions/classes" class="">&nbsp;&nbsp;&nbsp;&nbsp;Classes</a></li>
            
              
              

              

              <li><a href="/documentation/language-reference/definitions/coercion" class="">&nbsp;&nbsp;&nbsp;&nbsp;Coercion</a></li>
            
              
              

              

              <li><a href="/documentation/language-reference/definitions/level" class="">&nbsp;&nbsp;&nbsp;&nbsp;Level</a></li>
            
          
            
            

            

            <li><a href="/documentation/language-reference/expressions" class="">Expressions</a></li>

            
              
              

              

              <li><a href="/documentation/language-reference/expressions/goals" class="">&nbsp;&nbsp;&nbsp;&nbsp;Goals</a></li>
            
              
              

              

              <li><a href="/documentation/language-reference/expressions/universes" class="">&nbsp;&nbsp;&nbsp;&nbsp;Universes</a></li>
            
              
              

              

              <li><a href="/documentation/language-reference/expressions/pi" class="">&nbsp;&nbsp;&nbsp;&nbsp;Pi types</a></li>
            
              
              

              

              <li><a href="/documentation/language-reference/expressions/sigma" class="">&nbsp;&nbsp;&nbsp;&nbsp;Sigma types</a></li>
            
              
              

              

              <li><a href="/documentation/language-reference/expressions/let" class="">&nbsp;&nbsp;&nbsp;&nbsp;Let</a></li>
            
              
              

              

              <li><a href="/documentation/language-reference/expressions/case" class="">&nbsp;&nbsp;&nbsp;&nbsp;Case</a></li>
            
              
              

              

              <li><a href="/documentation/language-reference/expressions/class-ext" class="">&nbsp;&nbsp;&nbsp;&nbsp;Class extensions</a></li>
            
          
            
            

            

            <li><a href="/documentation/language-reference/prelude" class="">Prelude</a></li>

            
          
        </ul>
        
      </li>
    
      <li>
        
          
          

          <a href="/documentation/libraries"><span class="nav__sub-title">Libraries</span></a>
        

        
      </li>
    
  </ul>
</nav>

    
  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Functions">
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Functions
</h1>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> Functions</h4></header>
              <ul class="toc__menu">
  <li><a href="#non-recursive-definitions">Non-recursive definitions</a></li>
  <li><a href="#pattern-matching">Pattern matching</a></li>
  <li><a href="#elim">Elim</a></li>
  <li><a href="#recursive-functions">Recursive functions</a></li>
  <li><a href="#copattern-matching">Copattern matching</a></li>
  <li><a href="#lemmas">Lemmas</a></li>
</ul>
            </nav>
          </aside>
        
        <p>Functions in Arend are functions in the mathematical sense.
They can have arbitrary arity.
In particular, constants in Arend are just functions of arity 0.
<!--
 A definition of a function consists of its name, a signature which consists of a list of parameters and (possibly) a result type, and a body which is an expression that describes the behaviour of the function.
-->
A definition of a function <code class="highlighter-rouge">f</code> consists of the signature of <code class="highlighter-rouge">f</code> followed by the body of <code class="highlighter-rouge">f</code>.
The full syntax of function signatures is as follows:</p>

<pre><code class="language-arend">\func f p_1 ... p_n : T
</code></pre>
<p>where <code class="highlighter-rouge">f</code> is the name of the function, <code class="highlighter-rouge">p_1</code>, â€¦ <code class="highlighter-rouge">p_n</code> are named <a href="/language-reference/definitions/parameters">parameters</a> and
<code class="highlighter-rouge">T</code> is the result type. In some cases specification <code class="highlighter-rouge">: T</code> of the result type can be omitted depending on the 
definition of function body.
<!--The syntax of function body depends on whether the function is defined by pattern matching.
, where `f` is the name of the function, `p_1`, ... `p_n` are named [parameters](/language-reference/definitions/parameters), and `e` is an expression which denotes the result of the function.
You can also specify the result type of the function by writing `\func f p_1 ... p_n : T => e`, where `T` is an expression which denotes the result type.
In this case, `e` must have type `T`.
Often the typechecker can infer the result type, so usually you don't have to specify it explicitly.
--></p>

<p>There are several ways to define the body of a function. These ways are described below.</p>

<h2 id="non-recursive-definitions">Non-recursive definitions</h2>

<p>A non-recursive function can be defined simply by specifying an expression for the result of the function:</p>
<pre><code class="language-arend">\func f p_1 ... p_n : T =&gt; e
</code></pre>
<p>where <code class="highlighter-rouge">e</code> is an expression, which must be
of type <code class="highlighter-rouge">T</code> if it is specified. In such definitions the result type <code class="highlighter-rouge">: T</code> can often be omitted as the typechecker 
can usually infer it from <code class="highlighter-rouge">e</code>.</p>

<p>For example, to define the identity function on type <code class="highlighter-rouge">A</code>, write the following code:</p>

<pre><code class="language-arend">\func id (x : A) =&gt; x
</code></pre>

<p>A function with three parameters that returns the second one can be defined as follows:</p>

<pre><code class="language-arend">\func second (x : A) (y : B) (z : C) =&gt; y
</code></pre>

<p>You can explicitly specify the result types of these functions.
The definitions above are equivalent to the following definitions:</p>

<pre><code class="language-arend">\func id (x : A) : A =&gt; x
\func second (x : A) (y : B) (z : C) : B =&gt; y
</code></pre>

<p>Parameters of a function may appear in its body and in its result type.</p>

<h2 id="pattern-matching">Pattern matching</h2>

<p>Functions can be defined by pattern matching.
Let <code class="highlighter-rouge">D</code> be an <a href="/language-reference/definitions/data">inductive type</a> with constructors <code class="highlighter-rouge">con1</code> and <code class="highlighter-rouge">con2 Nat</code>.
You can define a function which maps <code class="highlighter-rouge">D</code> to natural numbers in such a way that <code class="highlighter-rouge">con1</code> is mapped to <code class="highlighter-rouge">0</code> and <code class="highlighter-rouge">con2 n</code> is mapped to <code class="highlighter-rouge">suc n</code>:</p>

<pre><code class="language-arend">\func f (d : D) : Nat
  | con1 =&gt; 0
  | con2 n =&gt; suc n
</code></pre>

<p>The result type of a function defined by pattern matching must be specified explicitly.
The general form of function definition by pattern matching is</p>

<pre><code class="language-arend">\func f (x_1 : T_1) ... (x_n : T_n) : R
  | clause_1
  ...
  | clause_k
</code></pre>

<p>where each <code class="highlighter-rouge">clause_i</code> is of the form</p>

<pre><code class="language-arend">p^i_1, ... p^i_n =&gt; e_i
</code></pre>

<p>where <code class="highlighter-rouge">p^i_j</code> is a pattern of type <code class="highlighter-rouge">T_i</code> (see below for the definition of a pattern) and <code class="highlighter-rouge">e_i</code> is an
expression of type <code class="highlighter-rouge">R[p^i_1/x_1, ... p^i_n/x_n]</code> (see <a href="/language-reference/expressions">this section</a> for the
discussion of the substitution operation and types of expressions).
Variables <code class="highlighter-rouge">x_1</code>, â€¦ <code class="highlighter-rouge">x_n</code> are not visible in expressions <code class="highlighter-rouge">e_i</code>. Note that this construction requires all the
variables to be matched on, that is the number of patterns in each clause must be <code class="highlighter-rouge">n</code> (but see 
Elim section below for partial pattern matching).</p>

<p>The clauses <code class="highlighter-rouge">clause_1,...clause_k</code> must cover all the cases. For example, if <code class="highlighter-rouge">con_1, con_2</code> are constructors
of an inductive type <code class="highlighter-rouge">D</code>, then any function <code class="highlighter-rouge">\func f (d : D) : T</code> that matches on constructors of <code class="highlighter-rouge">d : D</code> must be
of the from <code class="highlighter-rouge">\func f (d : D) : T | con_1 =&gt; e_1 | con_2 =&gt; e_2</code>. For instance, the definition
<code class="highlighter-rouge">\func f (d : D) : T | con_1 =&gt; e_1</code> is incomplete.</p>

<p>Pattern matching on constructors <code class="highlighter-rouge">left</code> and <code class="highlighter-rouge">right</code> of the <a href="/language-reference/prelude">interval type</a> <code class="highlighter-rouge">I</code> is
not allowed. For example, the definition <code class="highlighter-rouge">\func f (i : I) : Nat | left =&gt; 0 | right =&gt; 1</code> is not valid.</p>

<p>If some of the parameters of <code class="highlighter-rouge">f</code> are implicit, corresponding patterns must be either omitted or
specified explicitly by surrounding them in <code class="highlighter-rouge">{ }</code>.</p>

<p>Equivalently, the definition above can be written using the keyword <code class="highlighter-rouge">\with</code>:</p>
<pre><code class="language-arend"> \func f p_1 ... p_n : R \with { | clause_1 ... | clause_k } 
</code></pre>

<p>A <em>pattern</em> of type <code class="highlighter-rouge">T</code> can have one of the following forms:</p>

<ul>
  <li>A variable. If a variable <code class="highlighter-rouge">x</code> appears as a subpattern of <code class="highlighter-rouge">p_i</code> in a clause <code class="highlighter-rouge">| p_1 ... p_i ... =&gt; e</code>, 
it can be used in <code class="highlighter-rouge">e</code> and it will have type <code class="highlighter-rouge">T</code>. If this variable is not used anywhere, its name can be replaced 
with <code class="highlighter-rouge">_</code>.</li>
  <li><code class="highlighter-rouge">con s_1 ... s_m</code>, where <code class="highlighter-rouge">con (y_1 : A_1) ... (y_m : A_m)</code> is a constructor of a data type <code class="highlighter-rouge">D</code> and <code class="highlighter-rouge">s_1</code> â€¦ <code class="highlighter-rouge">s_m</code> are patterns.
In this case, <code class="highlighter-rouge">T</code> must be equal to <code class="highlighter-rouge">D</code> and pattern <code class="highlighter-rouge">s_i</code> must have type <code class="highlighter-rouge">A_i[s_1/y_1, ... s_{i-1}/y_{i-1}]</code>.
If some of the parameters of <code class="highlighter-rouge">con</code> are implicit, corresponding patterns must either be omitted or
enclosed in <code class="highlighter-rouge">{ }</code>.</li>
  <li><code class="highlighter-rouge">(s_1, ... s_m)</code>, where <code class="highlighter-rouge">s_1</code> â€¦ <code class="highlighter-rouge">s_m</code> are patterns.
In this case, <code class="highlighter-rouge">T</code> must be either a <a href="/language-reference/expressions/sigma">Sigma type</a> with parameters <code class="highlighter-rouge">(y_1 : A_1) ... (y_m : A_m)</code> or a <a href="/language-reference/definitions/classes">class</a> (or a <a href="/language-reference/definitions/records">record</a>) with fields <code class="highlighter-rouge">y_1 : A_1</code>, â€¦ <code class="highlighter-rouge">y_m : A_m</code>.
The pattern <code class="highlighter-rouge">s_i</code> must have type <code class="highlighter-rouge">A_i[s_1/y_1, ... s_{i-1}/y_{i-1}]</code>.
If <code class="highlighter-rouge">m</code> equals to 0, then <code class="highlighter-rouge">T</code> may also be a data type without constructors.
In this case, the right hand side <code class="highlighter-rouge">=&gt; e_i</code> of the clause in which such a pattern appears must be omitted.</li>
</ul>

<p>Also, a constructor or a tuple pattern may be an <em>as-pattern</em>.
This means that there might be an expressions of the form <code class="highlighter-rouge">\as x : E</code> after the pattern, where <code class="highlighter-rouge">x</code> is a variable and <code class="highlighter-rouge">E</code> is its type which can be omitted.
Then <code class="highlighter-rouge">x</code> is equivalent to this pattern.</p>

<p>Now, let us discuss how expressions of the form <code class="highlighter-rouge">f a_1 ... a_n</code> evaluate (see <a href="/language-reference/expressions/#evaluation">this section</a> for the definition of the reduction and evaluation relations).
To reduce an expression <code class="highlighter-rouge">E = f a_1 ... a_n</code>, we first evaluate expressions <code class="highlighter-rouge">a_1</code>, â€¦ <code class="highlighter-rouge">a_n</code> and match them with the patterns in the definition of <code class="highlighter-rouge">f</code> left to right, top to bottom.
If all patterns <code class="highlighter-rouge">p^i_1</code>, â€¦ <code class="highlighter-rouge">p^i_n</code> matches with <code class="highlighter-rouge">a_1</code>, â€¦ <code class="highlighter-rouge">a_n</code> for some i, then <code class="highlighter-rouge">E</code> reduces to <code class="highlighter-rouge">e_i[b_1/y_1, ... b_k/y_k]</code>,
where <code class="highlighter-rouge">y_1</code>, â€¦ <code class="highlighter-rouge">y_k</code> are variables that appear in <code class="highlighter-rouge">p^i_1</code>, â€¦ <code class="highlighter-rouge">p^i_n</code> and <code class="highlighter-rouge">b_1</code>, â€¦ <code class="highlighter-rouge">b_k</code> are subexpressions of <code class="highlighter-rouge">a_1</code>, â€¦ <code class="highlighter-rouge">a_n</code> corresponding to these variables.
If some argument cannot be matched with a pattern <code class="highlighter-rouge">con s_1 ... s_m</code> because it is of the form <code class="highlighter-rouge">con' ...</code> for some constructor <code class="highlighter-rouge">con'</code> different from <code class="highlighter-rouge">con</code>, then the evaluator skips the clause with this patterns and tries the next one.
If some argument cannot be matched with a pattern because it is not a constructor, then <code class="highlighter-rouge">E</code> does not reduce.
If none of the clauses match with arguments, then <code class="highlighter-rouge">E</code> also does not reduce.
Variables and patterns of the form <code class="highlighter-rouge">(s_1, ... s_m)</code> match with any expression.</p>

<p>Let us consider an example.
Let <code class="highlighter-rouge">B</code> be a data type with two constructors <code class="highlighter-rouge">T</code> and <code class="highlighter-rouge">F</code>.
Consider the following function:</p>

<pre><code class="language-arend">\func g (b b' : B) : Nat
  | T, _ =&gt; 0
  | _, T =&gt; 1
  | _, _ =&gt; 2
</code></pre>

<p>Let <code class="highlighter-rouge">x</code> be a variable and let <code class="highlighter-rouge">e</code> be an arbitrary expression.
If the first argument of <code class="highlighter-rouge">g a_1 a_2</code> is <code class="highlighter-rouge">T</code>, then the expression reduces to <code class="highlighter-rouge">0</code>, if it is <code class="highlighter-rouge">x</code>, then the expression does not reduce since the first pattern fails to match with <code class="highlighter-rouge">x</code>.
If the first argument is <code class="highlighter-rouge">F</code>, then the evaluator tries to match the second argument:</p>

<pre><code class="language-arend">g T e =&gt; 0
g x e -- does not reduce
g F T =&gt; 1
g F F =&gt; 2
g F x -- does not reduce
</code></pre>

<p>Note that patterns are matched left to right, top to bottom and not the other way around.
This means that even if a funcall matches the first clause, it may not evaluate.
For example, consider the following definition:</p>

<pre><code class="language-arend">\func \infix 4 &lt; (n m : Nat) : Bool
  | _, 0 =&gt; false
  | 0, suc _ =&gt; true
  | suc n, suc m =&gt; n &lt; m
</code></pre>

<p>The funcall <code class="highlighter-rouge">n &lt; 0</code> does not evaluate since it matches the first argument first, but funcalls <code class="highlighter-rouge">0 &lt; 0</code> and <code class="highlighter-rouge">suc n &lt; 0</code> both evaluate to <code class="highlighter-rouge">false</code>.</p>

<p>Sometimes you need to write a clause in which one of the parameters is a data type without constructors.
You can write pattern <code class="highlighter-rouge">()</code> which is called in this case <em>the absurd pattern</em>.
In this case, you must omit the right hand side of the clause.
For example, to define a function from the empty data type you can write:</p>

<pre><code class="language-arend">\data Empty

\func absurd {A : \Type} (e : Empty) : A
  | ()
</code></pre>

<p>You can often (but not always) omit the clause with an abusrd pattern completely.
For example, you can define function <code class="highlighter-rouge">absurd</code> as follows:</p>

<pre><code class="language-arend">\func absurd {A : \Type} (e : Empty) : A
</code></pre>

<h2 id="elim">Elim</h2>

<p>It is often true that one only needs to pattern match on a single parameter of a function (or a few parameters), but the function has much more parameters.
Then we need to repeat parameters on which we do not pattern match in each clause, which is inconvenient.
In this case, we can use the <code class="highlighter-rouge">\elim</code> construction:</p>

<pre><code class="language-arend">\func f (x_1 : A_1) ... (x_n : A_n) : R \elim x_{i_1}, ... x_{i_m}
  | p^1_1, ... p^1_m =&gt; e_1
  ...
  | p^k_1, ... p^k_m =&gt; e_k
</code></pre>

<p>where i_1, â€¦ i_m are integers such that 1 â‰¤ i_1 &lt; â€¦ &lt; i_m â‰¤ n.
In this case, parameters <code class="highlighter-rouge">x_{i_1}</code>, â€¦ <code class="highlighter-rouge">x_{i_m}</code> are <em>eliminated</em> and are not visible in expressions <code class="highlighter-rouge">e_1</code>, â€¦ <code class="highlighter-rouge">e_k</code>.
Other parameters of <code class="highlighter-rouge">f</code> are still visible in these expressions.
Note that it does not matter whether a parameter <code class="highlighter-rouge">x_i</code> is explicit or implicit when it is eliminated, the corresponding pattern is always explicit.</p>

<p>As an example, consider the following function which chooses one of its arguments depending on the value of its other argument:</p>

<pre><code class="language-arend">\func if (b : B) (t e : X) : X \elim b
  | T =&gt; t
  | F =&gt; e
</code></pre>

<h2 id="recursive-functions">Recursive functions</h2>

<p>Functions defined by pattern matching can be recursive.
That is, if <code class="highlighter-rouge">f</code> is a function as described above, then a reference to <code class="highlighter-rouge">f</code> may occur inside expressions <code class="highlighter-rouge">e_1</code>, â€¦ <code class="highlighter-rouge">e_k</code>.
Every function in Arend is a total function.
Thus, not every recursive definition is allowed.
In order for such a definition to be valid, the recursion must be <em>structural</em>.
This means that in a definition of <code class="highlighter-rouge">f</code> by pattern matching the arguments to recursive calls of <code class="highlighter-rouge">f</code> must be
subpatterns of the patterns for the arguments of <code class="highlighter-rouge">f</code>.</p>

<p>Functions can also be mutually recursive.
That is, we can have several functions which refer to each other.
In this case, there must be a linear order on the set of these functions <code class="highlighter-rouge">f_1</code>, â€¦ <code class="highlighter-rouge">f_n</code> such that the signature of <code class="highlighter-rouge">f_i</code> refers only to previous functions.
The bodies of the functions may refer to each other as long as the whole recursive system is structural.</p>

<h2 id="copattern-matching">Copattern matching</h2>

<p>If the result type of a function is a <a href="/language-reference/definitions/records">record</a> or a <a href="/language-reference/definitions/classes">class</a>,
then a function can also be defined by <em>copattern matching</em>, which has the following syntax:</p>

<pre><code class="language-arend">\func f (x_1 : A_1) ... (x_n : A_n) : C \cowith
  | coclause_1
  ...
  | coclause_k
</code></pre>

<p>where a <em>coclause</em> is a pair consisting of a field <code class="highlighter-rouge">g</code> of <code class="highlighter-rouge">C</code> and an expression <code class="highlighter-rouge">e</code> written <code class="highlighter-rouge">g =&gt; e</code>.
Such a function has the same semantics as a definition of an instance, that is it is equivalent to the following definition:</p>

<pre><code class="language-arend">\func f (x_1 : A_1) ... (x_n : A_n) =&gt; \new C {
  | coclause_1
  ...
  | coclause_k
}
</code></pre>

<p>See <a href="/language-reference/expressions/class-ext">this section</a> for the description of the involved constructions.</p>

<h2 id="lemmas">Lemmas</h2>

<p>A <em>lemma</em> is a function, the result type of which is a proposition and the body is considered to be a proof 
without computational content, and, thus, it does not evaluate.
To define a lemma use the keyword <code class="highlighter-rouge">\lemma</code> instead of <code class="highlighter-rouge">\func</code>.
If the result type of a lemma does not belong to <code class="highlighter-rouge">\Prop</code>, but is provably a proposition, you can use the keywords <a href="/language-reference/definitions/level/#level-of-a-type">\level</a> to define a lemma with this result type.
The fact that lemmas do not evaluate may greatly improve performance of typechecking if their proofs are too lengthy.</p>

        
      </section>

      <footer class="page__meta">
        
        


        
      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

    </div>

    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://github.com/JetBrains/Arend" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://twitter.com/ArendLang" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i> Twitter</a></li>
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2019 Arend. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script defer src="https://use.fontawesome.com/releases/v5.8.2/js/all.js" integrity="sha384-DJ25uNYET2XCl5ZF++U8eNxPWqcKohUUBUpKGlNLMchM7q4Wjg2CUpjHLaL8yYPH" crossorigin="anonymous"></script>










  </body>
</html>
