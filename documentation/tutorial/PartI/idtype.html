<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Equality - Arend Theorem Prover</title>
<meta name="description" content="The Arend Theorem Prover">



<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arend Theorem Prover">
<meta property="og:title" content="Equality">
<meta property="og:url" content="https://arend-lang.github.io/documentation/tutorial/PartI/idtype.html">


  <meta property="og:description" content="The Arend Theorem Prover">












<link rel="canonical" href="https://arend-lang.github.io/documentation/tutorial/PartI/idtype.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Arend",
      "url": "https://arend-lang.github.io/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arend Theorem Prover Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Arend Theorem Prover
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/about">About</a>
            </li><li class="masthead__menu-item">
              <a href="/documentation">Documentation</a>
            </li><li class="masthead__menu-item">
              <a href="/download">Download</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
    
      



<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>

  
  
  
  

  
  
  

  <ul class="nav__items">
    
      <li>
        
          
          

          <a href="/documentation/getting-started"><span class="nav__sub-title">Getting Started</span></a>
        

        
      </li>
    
      <li>
        
          
          

          <a href="/documentation/language-reference"><span class="nav__sub-title">Language Reference</span></a>
        

        
        <ul>
          
            
            

            

            <li><a href="/documentation/language-reference/lexical-structure" class="">Lexical structure</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/language-reference/definitions" class="">Definitions</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/language-reference/expressions" class="">Expressions</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/language-reference/prelude" class="">Prelude</a></li>

            
            
            
          
        </ul>
        
      </li>
    
      <li>
        
          
          

          <a href="/documentation/tutorial"><span class="nav__sub-title">Tutorial</span></a>
        

        
        <ul>
          
            
            

            

            <li><a href="/documentation/tutorial/PartI" class="">Part I: Dependent Types</a></li>

            
            
            
              
                
                

                

                <li><a href="/documentation/tutorial/PartI/synndef" class="">&nbsp;&nbsp;&nbsp;&nbsp;Basics</a></li>
              
                
                

                

                <li><a href="/documentation/tutorial/PartI/propsnproofs" class="">&nbsp;&nbsp;&nbsp;&nbsp;Propositions and Proofs</a></li>
              
                
                

                

                <li><a href="/documentation/tutorial/PartI/datanproofs" class="">&nbsp;&nbsp;&nbsp;&nbsp;Indexed Data Types</a></li>
              
                
                

                

                <li><a href="/documentation/tutorial/PartI/idtype" class="active">&nbsp;&nbsp;&nbsp;&nbsp;Equality</a></li>
              
                
                

                

                <li><a href="/documentation/tutorial/PartI/equalityex" class="">&nbsp;&nbsp;&nbsp;&nbsp;Proofs of Equality</a></li>
              
                
                

                

                <li><a href="/documentation/tutorial/PartI/records" class="">&nbsp;&nbsp;&nbsp;&nbsp;Classes and Records</a></li>
              
                
                

                

                <li><a href="/documentation/tutorial/PartI/case" class="">&nbsp;&nbsp;&nbsp;&nbsp;Case Expression</a></li>
              
                
                

                

                <li><a href="/documentation/tutorial/PartI/universes" class="">&nbsp;&nbsp;&nbsp;&nbsp;Universes, Induction, Specifications</a></li>
              
            
          
            
            

            

            <li><a href="/documentation/tutorial/PartII" class="">Part II: Homotopy Type Theory</a></li>

            
            
            
          
        </ul>
        
      </li>
    
      <li>
        
          
          

          <a href="/documentation/libraries"><span class="nav__sub-title">Libraries</span></a>
        

        
      </li>
    
      <li>
        
          
          

          <a href="/documentation/standard-tactics"><span class="nav__sub-title">Standard metas</span></a>
        

        
        <ul>
          
            
            

            

            <li><a href="/documentation/standard-tactics/meta" class="">Unclassified metas</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/standard-tactics/paths-meta" class="">Paths metas</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/standard-tactics/function-meta" class="">Functional metas</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/standard-tactics/algebra-meta" class="">Algebraic metas</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/standard-tactics/logic-meta" class="">Logical metas</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/standard-tactics/debug-meta" class="">Debugging metas</a></li>

            
            
            
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Equality">
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Equality
</h1>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> Equality</h4></header>
              <ul class="toc__menu"><li><a href="#symmetry-transitivity-leibniz-principle">Symmetry, transitivity, Leibniz principle</a></li><li><a href="#definition-of-">Definition of =</a></li><li><a href="#functional-extensionality">Functional extensionality</a></li><li><a href="#eliminators">Eliminators</a></li><li><a href="#left--right">left = right</a></li><li><a href="#coe-and-transport">coe and transport</a></li><li><a href="#proofs-of-non-equalities">Proofs of non-equalities</a></li></ul>

            </nav>
          </aside>
        
        <p class="notice--success">The source code for this module: <a href="https://github.com/arend-lang/tutorial-code/blob/master/PartI/src/Equality.ard">PartI/Equality.ard</a> <br />
The source code for the exercises: <a href="https://github.com/arend-lang/tutorial-code/blob/master/PartI/src/Exercises/EqualityEx.ard">PartI/EqualityEx.ard</a></p>

<p>In the previous modules we treated the identity type <span class="inl-highlight"><span class="o">=</span></span> in a rather hand-wavy manner as in most of the cases
we needed just reflexivity <span class="inl-highlight">idp {A <span class="o">:</span> <span class="kt">\Type</span>} {a <span class="o">:</span> A} <span class="o">:</span> a <span class="o">=</span> a</span>. Here we will get into details of the definition
of the identity type and explain some key aspects of it, which will be important for writing more advanced proofs. Along the
way we introduce the <em>interval type</em> <span class="inl-highlight">I</span>, whose properties are essentially determined by the function
<span class="inl-highlight">coe</span>, playing the role of <em>eliminator</em> for <span class="inl-highlight">I</span>. In order to clarify this we briefly
recall the general concept of eliminator.</p>

<h1 id="symmetry-transitivity-leibniz-principle">Symmetry, transitivity, Leibniz principle</h1>

<p>First of all, we show that the identity type satisfies some basic properties of equality: it is an equivalence relation and
it satisfies the Leibniz principle.</p>

<p>The Leibniz principle says that if <span class="inl-highlight">a</span> and <span class="inl-highlight">a’</span> satisfy the same properties, then they are
equal. It can be easily proven that <span class="inl-highlight"><span class="o">=</span></span> satisfies this principle:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> Leibniz {A <span class="o">:</span> <span class="kt">\Type</span>} {a a' <span class="o">:</span> A}
  (f <span class="o">:</span> <span class="k">\Pi</span> (P <span class="o">:</span> A <span class="o">-&gt;</span> <span class="kt">\Type</span>) <span class="o">-&gt;</span> <span class="k">\Sigma</span> (P a <span class="o">-&gt;</span> P a') (P a' <span class="o">-&gt;</span> P a)) <span class="o">:</span> a <span class="o">=</span> a'
  <span class="o">=&gt;</span> (f (<span class="k">\lam</span> x <span class="o">=&gt;</span> a <span class="o">=</span> x)).<span class="n">1</span> idp</code></pre></div></div>

<p>The inverse Leibniz principle (which we will call merely Leibniz principle as well) says that if <span class="inl-highlight">a <span class="o">=</span> a’</span>, then
<span class="inl-highlight">a</span> and <span class="inl-highlight">a’</span> satisfy the same properties, that is if <span class="inl-highlight">P a</span> is true, then
<span class="inl-highlight">P a’</span> is true. The proof of this is easy, but requires some constructs that will be introduced very shortly
further in this module:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> transport {A <span class="o">:</span> <span class="kt">\Type</span>} (B <span class="o">:</span> A <span class="o">-&gt;</span> <span class="kt">\Type</span>) {a a' <span class="o">:</span> A} (p <span class="o">:</span> a <span class="o">=</span> a') (b <span class="o">:</span> B a) <span class="o">:</span> B a'
    <span class="o">=&gt;</span> coe (<span class="k">\lam</span> i <span class="o">=&gt;</span> B (p <span class="o">@</span> i)) b right</code></pre></div></div>

<p>Using this latter Leibniz principle, it is easy to prove that <span class="inl-highlight"><span class="o">=</span></span> satisfies (almost) all the properties
of equality. For example, the following properties:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">-- symmetry</span>
<span class="k">\func</span> inv {A <span class="o">:</span> <span class="kt">\Type</span>} {a a' <span class="o">:</span> A} (p <span class="o">:</span> a <span class="o">=</span> a') <span class="o">:</span> a' <span class="o">=</span> a
    <span class="o">=&gt;</span> transport (<span class="k">\lam</span> x <span class="o">=&gt;</span> x <span class="o">=</span> a) p idp

<span class="c">-- transitivity</span>
<span class="k">\func</span> trans {A <span class="o">:</span> <span class="kt">\Type</span>} {a a' a'' <span class="o">:</span> A} (p <span class="o">:</span> a <span class="o">=</span> a') (q <span class="o">:</span> a' <span class="o">=</span> a'') <span class="o">:</span> a <span class="o">=</span> a''
    <span class="o">=&gt;</span> transport (<span class="k">\lam</span> x <span class="o">=&gt;</span> a <span class="o">=</span> x) q p

<span class="c">-- congruence</span>
<span class="k">\func</span> pmap {A B <span class="o">:</span> <span class="kt">\Type</span>} (f <span class="o">:</span> A <span class="o">-&gt;</span> B) {a a' <span class="o">:</span> A} (p <span class="o">:</span> a <span class="o">=</span> a') <span class="o">:</span> f a <span class="o">=</span> f a'
    <span class="o">=&gt;</span> transport (<span class="k">\lam</span> x <span class="o">=&gt;</span> f a <span class="o">=</span> f x) p idp</code></pre></div></div>

<p class="notice--info"><strong>Exercise 1:</strong> Define congruence for functions with two arguments via transport.
It is allowed to use any functions defined via transport.</p>

<p class="notice--info"><strong>Exercise 2:</strong> Prove that <span class="inl-highlight">transport</span> can be defined via <span class="inl-highlight">pmap</span> and <span class="inl-highlight">repl</span> and vice versa.
The function <span class="inl-highlight">repl</span> says that if two types are equal then there exists a function between them.</p>

<h1 id="definition-of-">Definition of =</h1>

<p>The central ingredient of the definition of the identity type is the <em>interval type</em> <span class="inl-highlight">I</span> contained in Prelude.
The type <span class="inl-highlight">I</span> looks like a two-element data type with constructors <span class="inl-highlight">left</span> and <span class="inl-highlight">right</span>,
but actually it is not: these constructors are made equal (by means of <span class="inl-highlight">coe</span>). Of course, pattern matching on
<span class="inl-highlight">I</span> is prohibited since it can be used to derive <span class="inl-highlight">Empty <span class="o">=</span> Unit</span>.</p>

<p>The equality <span class="inl-highlight">left <span class="o">=</span> right</span> implies that some <span class="inl-highlight">a <span class="o">:</span> A</span> and <span class="inl-highlight">a’ <span class="o">:</span> A</span> are equal if and only if
there exists a function <span class="inl-highlight">f <span class="o">:</span> I <span class="o">-&gt;</span> A</span> such that <span class="inl-highlight">f left <span class="o">==</span>&gt; a</span> and <span class="inl-highlight">f right <span class="o">==</span>&gt; a’</span>
(where <span class="inl-highlight"><span class="o">==</span>&gt;</span> denotes computational equality). The type <span class="inl-highlight">a <span class="o">=</span> {A} a’</span> is defined simply as the type
of all functions <span class="inl-highlight">f <span class="o">:</span> I <span class="o">-&gt;</span> A</span> satisfying this property. The constructor <span class="inl-highlight">path (f <span class="o">:</span> I <span class="o">-&gt;</span> A) <span class="o">:</span> f left <span class="o">=</span> f right</span>
allows to construct equality proofs out of such functions and the function <span class="inl-highlight"><span class="o">@</span> (p <span class="o">:</span> a <span class="o">=</span> a’) (i <span class="o">:</span> I) <span class="o">:</span> A</span> does the
inverse operation:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>path f <span class="o">@</span> i <span class="o">==</span>&gt; f i <span class="c">-- beta-equivalence</span>
path (<span class="k">\lam</span> i <span class="o">=&gt;</span> p <span class="o">@</span> i) <span class="o">==</span>&gt; p <span class="c">-- eta-equivalence</span></code></pre></div></div>

<p>In order to prove reflexivity <span class="inl-highlight">idp</span> we can simply take the constant function <span class="inl-highlight"><span class="k">\lam</span> <span class="u">_</span> <span class="o">=&gt;</span> a <span class="o">:</span> I <span class="o">-&gt;</span> A</span>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> idp {A <span class="o">:</span> <span class="kt">\Type</span>} {a <span class="o">:</span> A} <span class="o">:</span> a <span class="o">=</span> a <span class="o">=&gt;</span> path (<span class="k">\lam</span> <span class="u">_</span> <span class="o">=&gt;</span> a)</code></pre></div></div>

<p class="notice--info"><strong>Exercise 3:</strong> Prove that <span class="inl-highlight">left <span class="o">=</span> right</span> without using <span class="inl-highlight">transport</span> or <span class="inl-highlight">coe</span>.</p>

<p>If <span class="inl-highlight">f <span class="o">:</span> A <span class="o">-&gt;</span> B</span> and <span class="inl-highlight">g <span class="o">:</span> I <span class="o">-&gt;</span> A</span>, then <span class="inl-highlight">g</span> determines a proof of the equality
<span class="inl-highlight">g left <span class="o">=</span> g right</span> and the congruence <span class="inl-highlight">pmap</span> can be interpreted as simply the composition of
<span class="inl-highlight">f</span> and <span class="inl-highlight">g</span>. This observation suggests an alternative definition of <span class="inl-highlight">pmap</span>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> pmap {A B <span class="o">:</span> <span class="kt">\Type</span>} (f <span class="o">:</span> A <span class="o">-&gt;</span> B) {a a' <span class="o">:</span> A} (p <span class="o">:</span> a <span class="o">=</span> a') <span class="o">:</span> f a <span class="o">=</span> f a'
    <span class="o">=&gt;</span> path (<span class="k">\lam</span> i <span class="o">=&gt;</span> f (p <span class="o">@</span> i))</code></pre></div></div>

<p>This definition of <span class="inl-highlight">pmap</span> behaves better than others with respect to computational properties. For example,
<span class="inl-highlight">pmap id</span> is computationally the same as <span class="inl-highlight">id</span> and <span class="inl-highlight">pmap (f . g)</span> is
computationally the same as <span class="inl-highlight">pmap f . pmap g</span>, where (.) is the composition:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> pmap-idp {A <span class="o">:</span> <span class="kt">\Type</span>} {a a' <span class="o">:</span> A} (p <span class="o">:</span> a <span class="o">=</span> a') <span class="o">:</span> pmap {A} (<span class="k">\lam</span> x <span class="o">=&gt;</span> x) p <span class="o">=</span> p
    <span class="o">=&gt;</span> idp</code></pre></div></div>

<p class="notice--info"><strong>Exercise 4:</strong> Prove that <span class="inl-highlight">a <span class="o">=</span> {A} a’</span> and <span class="inl-highlight">b <span class="o">=</span> {B} b’</span> implies <span class="inl-highlight">(a<span class="o">,</span>b) <span class="o">=</span> {<span class="k">\Sigma</span> A B} (a’<span class="o">,</span>b’)</span> without using <span class="inl-highlight">transport</span>.</p>

<p class="notice--info"><strong>Exercise 5:</strong> Prove that <span class="inl-highlight">p <span class="o">=</span> {<span class="k">\Sigma</span> (x <span class="o">:</span> A) (B x)} p’</span> implies <span class="inl-highlight">p.<span class="n">1</span> <span class="o">=</span> {A} p’.<span class="n">1</span></span> without using <span class="inl-highlight">transport</span>.</p>

<h1 id="functional-extensionality">Functional extensionality</h1>

<p>Function extensionality is a principle saying that if two functions <span class="inl-highlight">f</span> and <span class="inl-highlight">g</span> are equal
pointwise, then they are equal functions. Our definition of equality allows us to prove this principle very easily:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> funExt {A <span class="o">:</span> <span class="kt">\Type</span>} (B <span class="o">:</span> A <span class="o">-&gt;</span> <span class="kt">\Type</span>) {f g <span class="o">:</span> <span class="k">\Pi</span> (a <span class="o">:</span> A) <span class="o">-&gt;</span> B a}
    (p <span class="o">:</span> <span class="k">\Pi</span> (a <span class="o">:</span> A) <span class="o">-&gt;</span> f a <span class="o">=</span> g a) <span class="o">:</span> f <span class="o">=</span> g
    <span class="o">=&gt;</span> path (<span class="k">\lam</span> i <span class="o">=&gt;</span> <span class="k">\lam</span> a <span class="o">=&gt;</span> p a <span class="o">@</span> i)</code></pre></div></div>

<p>This useful principle is unprovable in many other intensional dependently typed theories. In such theories function extensionality
can be introduced as an axiom, that is as a function without implementation, however adding new axioms worsens computational properties
of the theory. For example, if we add the axiom of excluded middle <span class="inl-highlight">lem</span>, then we can define a constant
<span class="inl-highlight">ugly_num <span class="o">:</span> Nat</span> that does not evaluate to any concrete natural number:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> lem <span class="o">:</span> <span class="k">\Pi</span> (X <span class="o">:</span> <span class="kt">\Type</span>) <span class="o">-&gt;</span> Either X (X <span class="o">-&gt;</span> Empty) <span class="o">=&gt;</span> <span class="g">{?}</span>
<span class="k">\func</span> ugly_num <span class="o">:</span> Nat <span class="o">=&gt;</span> <span class="k">\case</span> lem Nat <span class="k">\with</span> { <span class="o">|</span> Left <span class="o">=&gt;</span> <span class="n">0</span> <span class="o">|</span> Right <span class="o">=&gt;</span> <span class="n">1</span> }</code></pre></div></div>

<p class="notice--info"><strong>Exercise 6:</strong> Prove that <span class="inl-highlight">(<span class="k">\lam</span> x <span class="o">=&gt;</span> not (not x)) <span class="o">=</span> (<span class="k">\lam</span> x <span class="o">=&gt;</span> x)</span>.</p>

<h1 id="eliminators">Eliminators</h1>

<p>Elimination principles for a data type <span class="inl-highlight">D</span> specify what kind of data
should be provided in order to define a function from <span class="inl-highlight">D</span> to a non-dependent or
dependent type. And, essentially, these principles say that it is enough to show how “generators”
(that is constructors) of <span class="inl-highlight">D</span> are mapped to a type <span class="inl-highlight">A</span> and
that that would uniquely determine a function <span class="inl-highlight">D <span class="o">-&gt;</span> A</span>. For example, eliminators
for <span class="inl-highlight">Nat</span> and <span class="inl-highlight">Bool</span>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">-- Dependent eliminator for Nat (induction).</span>
<span class="k">\func</span> Nat-elim (P <span class="o">:</span> Nat <span class="o">-&gt;</span> <span class="kt">\Type</span>)
               (z <span class="o">:</span> P zero)
               (s <span class="o">:</span> <span class="k">\Pi</span> (n <span class="o">:</span> Nat) <span class="o">-&gt;</span> P n <span class="o">-&gt;</span> P (suc n))
               (x <span class="o">:</span> Nat) <span class="o">:</span> P x <span class="k">\elim</span> x
  <span class="o">|</span> zero <span class="o">=&gt;</span> z
  <span class="o">|</span> suc n <span class="o">=&gt;</span> s n (Nat-elim P z s n)

<span class="c">-- Non-dependent eliminator for Nat (recursion).</span>
<span class="k">\func</span> Nat-rec (P <span class="o">:</span> <span class="kt">\Type</span>)
              (z <span class="o">:</span> P)
              (s <span class="o">:</span> Nat <span class="o">-&gt;</span> P <span class="o">-&gt;</span> P)
              (x <span class="o">:</span> Nat) <span class="o">:</span> P <span class="k">\elim</span> x
  <span class="o">|</span> zero <span class="o">=&gt;</span> z
  <span class="o">|</span> suc n <span class="o">=&gt;</span> s n (Nat-rec P z s n)

<span class="c">-- Dependent eliminator for Bool (recursor for Bool is just 'if').</span>
<span class="k">\func</span> Bool-elim (P <span class="o">:</span> Bool <span class="o">-&gt;</span> <span class="kt">\Type</span>)
                (t <span class="o">:</span> P true)
                (f <span class="o">:</span> P false)
                (x <span class="o">:</span> Bool) <span class="o">:</span> P x <span class="k">\elim</span> x
  <span class="o">|</span> true <span class="o">=&gt;</span> t
  <span class="o">|</span> false <span class="o">=&gt;</span> f</code></pre></div></div>

<p class="notice--info"><strong>Exercise 7:</strong> Define factorial via Nat-rec (i.e., without recursion and pattern matching).</p>

<p class="notice--info"><strong>Exercise 8:</strong> Prove associativity of Nat.+ via Nat-elim (i.e., without recursion and pattern matching).</p>

<p class="notice--info"><strong>Exercise 9:</strong> Define recursor and eliminator for <span class="inl-highlight"><span class="k">\data</span> D <span class="o">|</span> con1 Nat <span class="o">|</span> con2 D D <span class="o">|</span> con3 (Nat <span class="o">-&gt;</span> D)</span>.</p>

<p class="notice--info"><strong>Exercise 10:</strong> Define recursor and eliminator for <span class="inl-highlight">List</span>.</p>

<p>The function <span class="inl-highlight">coe</span> thus defines dependent eliminator for <span class="inl-highlight">I</span>,
it says that in order to define <span class="inl-highlight">f <span class="o">:</span> <span class="k">\Pi</span> (i <span class="o">:</span> I) <span class="o">-&gt;</span> P i</span> for some <span class="inl-highlight">P <span class="o">:</span> I <span class="o">-&gt;</span> <span class="kt">\Type</span></span>
it is enough to specify <span class="inl-highlight">f left</span>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> coe (P <span class="o">:</span> I <span class="o">-&gt;</span> <span class="kt">\Type</span>)
          (a <span class="o">:</span> P left)
          (i <span class="o">:</span> I) <span class="o">:</span> P i <span class="k">\elim</span> i
  <span class="o">|</span> left <span class="o">=&gt;</span> a</code></pre></div></div>

<p class="notice--info"><strong>Exercise 11:</strong> We defined <span class="inl-highlight">transport</span> via <span class="inl-highlight">coe</span>.
It is possible to define a special case of <span class="inl-highlight">coe</span> via <span class="inl-highlight">transport</span>.
Define <span class="inl-highlight">coe0 (A <span class="o">:</span> I <span class="o">-&gt;</span> <span class="kt">\Type</span>) (a <span class="o">:</span> A left) <span class="o">:</span> A right</span> via <span class="inl-highlight">transport</span>.
Is it possible to define <span class="inl-highlight">transport</span> via <span class="inl-highlight">coe0</span>?</p>

<p class="notice--info"><strong>Exercise 12:</strong> Define a function <span class="inl-highlight">B right <span class="o">-&gt;</span> B left</span>.</p>

<h1 id="left--right">left = right</h1>

<p>With the use of the function <span class="inl-highlight">coe</span>, we now prove that <span class="inl-highlight">I</span> has one element:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> left=i (i <span class="o">:</span> I) <span class="o">:</span> left <span class="o">=</span> i
  <span class="c">-- | left =&gt; idp</span>
  <span class="o">=&gt;</span> coe (<span class="k">\lam</span> i <span class="o">=&gt;</span> left <span class="o">=</span> i) idp i

<span class="c">-- In particular left = right.</span>
<span class="k">\func</span> left=right <span class="o">:</span> left <span class="o">=</span> right <span class="o">=&gt;</span> left=i right</code></pre></div></div>

<h1 id="coe-and-transport">coe and transport</h1>

<p>Functions <span class="inl-highlight">coe</span> and <span class="inl-highlight">transport</span> are closely related. Recall the
definition of <span class="inl-highlight">transport</span> given earlier in this module:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> transport {A <span class="o">:</span> <span class="kt">\Type</span>} (B <span class="o">:</span> A <span class="o">-&gt;</span> <span class="kt">\Type</span>) {a a' <span class="o">:</span> A} (p <span class="o">:</span> a <span class="o">=</span> a') (b <span class="o">:</span> B a) <span class="o">:</span> B a'
     <span class="o">=&gt;</span> coe (<span class="k">\lam</span> i <span class="o">=&gt;</span> B (p <span class="o">@</span> i)) b right</code></pre></div></div>

<p>Denote <span class="inl-highlight"><span class="k">\lam</span> i <span class="o">=&gt;</span> B (p <span class="o">@</span> i)</span> as <span class="inl-highlight">B’</span>. Then <span class="inl-highlight">B’ <span class="o">:</span> I <span class="o">-&gt;</span> <span class="kt">\Type</span></span>,
<span class="inl-highlight">B’ left <span class="o">==</span>&gt; B a</span>, <span class="inl-highlight">B’ right <span class="o">==</span>&gt; B a’</span> and 
<span class="inl-highlight"><span class="k">\lam</span> x <span class="o">=&gt;</span> coe B’ x right <span class="o">:</span> B’ left <span class="o">-&gt;</span> B’ right</span>.</p>

<h1 id="proofs-of-non-equalities">Proofs of non-equalities</h1>

<p>In order to prove that <span class="inl-highlight">true</span> is not equal to <span class="inl-highlight">false</span> it is enough to define a
function <span class="inl-highlight">T <span class="o">:</span> Bool <span class="o">-&gt;</span> <span class="kt">\Type</span></span> such that <span class="inl-highlight">T true</span> is the unit type and 
<span class="inl-highlight">T false</span> is the empty type. Then the contradiction can be easily derived from 
<span class="inl-highlight">true <span class="o">=</span> false</span> by means of <span class="inl-highlight">transport</span>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> true/=false (p <span class="o">:</span> true <span class="o">=</span> false) <span class="o">:</span> Empty <span class="o">=&gt;</span> transport T p unit</code></pre></div></div>

<p>Note that it is not possible to prove that <span class="inl-highlight">left</span> is not equal to <span class="inl-highlight">right</span> 
since such <span class="inl-highlight">T</span> cannot be defined neither recursively nor inductively:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">-- This function does not typecheck!</span>
<span class="k">\func</span> TI (b <span class="o">:</span> I)
  <span class="o">|</span> left <span class="o">=&gt;</span> <span class="k">\Sigma</span>
  <span class="o">|</span> right <span class="o">=&gt;</span> Empty</code></pre></div></div>

<p class="notice--info"><strong>Exercise 13:</strong> Prove that <span class="inl-highlight"><span class="n">0</span></span> does not equal to <span class="inl-highlight">suc x</span>.</p>

<p class="notice--info"><strong>Exercise 14:</strong> Prove that <span class="inl-highlight">fac</span> does not equal to <span class="inl-highlight">suc</span>.</p>

        
      </section>

      <footer class="page__meta">
        
        


        
      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://github.com/JetBrains/Arend" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://twitter.com/ArendLang" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i> Twitter</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 Arend. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
