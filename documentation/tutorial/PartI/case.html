<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.20.1 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Case Expression - Arend Theorem Prover</title>
<meta name="description" content="The Arend Theorem Prover">



<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arend Theorem Prover">
<meta property="og:title" content="Case Expression">
<meta property="og:url" content="https://arend-lang.github.io/documentation/tutorial/PartI/case.html">


  <meta property="og:description" content="The Arend Theorem Prover">












<link rel="canonical" href="https://arend-lang.github.io/documentation/tutorial/PartI/case.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Arend",
      "url": "https://arend-lang.github.io/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arend Theorem Prover Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Arend Theorem Prover
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/about">About</a>
            </li><li class="masthead__menu-item">
              <a href="/documentation">Documentation</a>
            </li><li class="masthead__menu-item">
              <a href="/download">Download</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
    
      



<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>

  
  
  
  

  
  
  

  <ul class="nav__items">
    
      <li>
        
          
          

          <a href="/documentation/getting-started"><span class="nav__sub-title">Getting Started</span></a>
        

        
      </li>
    
      <li>
        
          
          

          <a href="/documentation/language-reference"><span class="nav__sub-title">Language Reference</span></a>
        

        
        <ul>
          
            
            

            

            <li><a href="/documentation/language-reference/lexical-structure" class="">Lexical structure</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/language-reference/definitions" class="">Definitions</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/language-reference/expressions" class="">Expressions</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/language-reference/prelude" class="">Prelude</a></li>

            
            
            
          
        </ul>
        
      </li>
    
      <li>
        
          
          

          <a href="/documentation/tutorial"><span class="nav__sub-title">Tutorial</span></a>
        

        
        <ul>
          
            
            

            

            <li><a href="/documentation/tutorial/PartI" class="">Part I: Dependent Types</a></li>

            
            
            
              
                
                

                

                <li><a href="/documentation/tutorial/PartI/synndef" class="">&nbsp;&nbsp;&nbsp;&nbsp;Basics</a></li>
              
                
                

                

                <li><a href="/documentation/tutorial/PartI/propsnproofs" class="">&nbsp;&nbsp;&nbsp;&nbsp;Propositions and Proofs</a></li>
              
                
                

                

                <li><a href="/documentation/tutorial/PartI/datanproofs" class="">&nbsp;&nbsp;&nbsp;&nbsp;Indexed Data Types</a></li>
              
                
                

                

                <li><a href="/documentation/tutorial/PartI/idtype" class="">&nbsp;&nbsp;&nbsp;&nbsp;Equality</a></li>
              
                
                

                

                <li><a href="/documentation/tutorial/PartI/equalityex" class="">&nbsp;&nbsp;&nbsp;&nbsp;Proofs of Equality</a></li>
              
                
                

                

                <li><a href="/documentation/tutorial/PartI/records" class="">&nbsp;&nbsp;&nbsp;&nbsp;Classes and Records</a></li>
              
                
                

                

                <li><a href="/documentation/tutorial/PartI/case" class="active">&nbsp;&nbsp;&nbsp;&nbsp;Case Expression</a></li>
              
                
                

                

                <li><a href="/documentation/tutorial/PartI/universes" class="">&nbsp;&nbsp;&nbsp;&nbsp;Universes, Induction, Specifications</a></li>
              
            
          
            
            

            

            <li><a href="/documentation/tutorial/PartII" class="">Part II: Homotopy Type Theory</a></li>

            
            
            
          
        </ul>
        
      </li>
    
      <li>
        
          
          

          <a href="/documentation/libraries"><span class="nav__sub-title">Libraries</span></a>
        

        
      </li>
    
      <li>
        
          
          

          <a href="/documentation/standard-tactics"><span class="nav__sub-title">Standard metas</span></a>
        

        
        <ul>
          
            
            

            

            <li><a href="/documentation/standard-tactics/meta" class="">Unclassified metas</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/standard-tactics/path-meta" class="">Path metas</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/standard-tactics/function-meta" class="">Functional metas</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/standard-tactics/algebra-meta" class="">Algebraic metas</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/standard-tactics/logic-meta" class="">Logical metas</a></li>

            
            
            
          
            
            

            

            <li><a href="/documentation/standard-tactics/debug-meta" class="">Debugging metas</a></li>

            
            
            
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Case Expression">
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Case Expression
</h1>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> Case Expression</h4></header>
              <ul class="toc__menu">
  <li><a href="#filter-via-case-and-via-helper">filter via \case and via helper</a></li>
  <li><a href="#remark-on-elim-vs-case">Remark on \elim vs \case</a></li>
  <li><a href="#case-in-dependently-typed-languages">\case in dependently typed languages</a></li>
  <li><a href="#case-with-several-arguments">\case with several arguments</a></li>
  <li><a href="#proof-of-a-fact-about-filter-via-case">Proof of a fact about filter via \case</a></li>
  <li><a href="#elim-in-case">\elim in \case</a></li>
  <li><a href="#matching-on-idp-in-case">Matching on idp in \case</a></li>
  <li><a href="#one-more-example-of-case">One more example of \case</a></li>
  <li><a href="#views">Views</a></li>
  <li><a href="#decidable-predicates">Decidable predicates</a></li>
  <li><a href="#decidable-equality">Decidable equality</a></li>
  <li><a href="#decidable-predicates-and-functions-a---bool">Decidable predicates and functions A -&gt; Bool</a></li>
</ul>

            </nav>
          </aside>
        
        <p class="notice--success">The source code for this module: <a href="https://github.com/arend-lang/tutorial-code/blob/master/PartI/src/Case.ard">PartI/Case.ard</a> <br />
The source code for the exercises: <a href="https://github.com/arend-lang/tutorial-code/blob/master/PartI/src/Exercises/CaseEx.ard">PartI/CaseEx.ard</a></p>

<p>In this module we discuss three themes.</p>

<p>Firstly, we discuss case expressions and alternatives to them in the form of the helper
functions. We also compare <span class="inl-highlight"><span class="k">\case</span></span> to <span class="inl-highlight"><span class="k">\elim</span></span>, point
out at peculiarities of using case expressions in a dependently typed language and 
explain pattern matching on <span class="inl-highlight">idp</span> in <span class="inl-highlight"><span class="k">\case</span></span>.</p>

<p>Secondly, we explain a technique of <em>views</em>, allowing to define custom pattern matching
principles.</p>

<p>Finally, we discuss an important class of predicates: <em>decidable predicates</em>, which are precisely
the predicates <span class="inl-highlight">P <span class="o">:</span> A <span class="o">-&gt;</span> <span class="kt">\Type</span></span> such that for every <span class="inl-highlight">x <span class="o">:</span> A</span>
either <span class="inl-highlight">P x</span> or the negation of <span class="inl-highlight">P x</span> is provable.</p>

<h1 id="filter-via-case-and-via-helper">filter via \case and via helper</h1>

<p>Case expressions, like in Haskell, can be used for pattern matching on arbitrary expressions. For example,
let us define the function <span class="inl-highlight">filter</span> that removes from a list <span class="inl-highlight">xs <span class="o">:</span> List A</span> all
elements that do not satisfy some predicate <span class="inl-highlight">p <span class="o">:</span> A <span class="o">-&gt;</span> Bool</span>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> filter {A <span class="o">:</span> <span class="kt">\Type</span>} (p <span class="o">:</span> A <span class="o">-&gt;</span> Bool) (xs <span class="o">:</span> List A) <span class="o">:</span> List A <span class="k">\elim</span> xs
  <span class="o">|</span> nil <span class="o">=&gt;</span> nil
  <span class="o">|</span> cons x xs <span class="o">=&gt;</span> <span class="k">\case</span> p x <span class="k">\with</span> {
    <span class="o">|</span> true <span class="o">=&gt;</span> cons x (filter p xs)
    <span class="o">|</span> false <span class="o">=&gt;</span> filter p xs
  }</code></pre></div></div>

<p>Here we used case expression for pattern matching on the expression <span class="inl-highlight">p x</span>. Alternatively,
we could introduce a helper function, defined by pattern matching, and invoke it in the place of
<span class="inl-highlight"><span class="k">\case</span></span> usage:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> filter' {A <span class="o">:</span> <span class="kt">\Type</span>} (p <span class="o">:</span> A <span class="o">-&gt;</span> Bool) (xs <span class="o">:</span> List A) <span class="o">:</span> List A <span class="k">\elim</span> xs
  <span class="o">|</span> nil <span class="o">=&gt;</span> nil
  <span class="o">|</span> cons x xs <span class="o">=&gt;</span> helper (p x) x (filter p xs)
  <span class="k">\where</span>
    <span class="k">\func</span> helper {A <span class="o">:</span> <span class="kt">\Type</span>} (b <span class="o">:</span> Bool) (x <span class="o">:</span> A) (r <span class="o">:</span> List A) <span class="o">:</span> List A <span class="k">\elim</span> b
      <span class="o">|</span> true <span class="o">=&gt;</span> cons x r
      <span class="o">|</span> false <span class="o">=&gt;</span> r</code></pre></div></div>

<p>Actually, every usage of case expression can be replaced in this way with an invocation of a helper function. 
It is just sometimes more convenient to use short case expressions instead of introducing countless
amount of helpers.</p>

<p class="notice--info"><strong>Exercise 1:</strong> Implement any sorting algorithm using \case for pattern matching on the result of comparison of elements
of a list.</p>

<h1 id="remark-on-elim-vs-case">Remark on \elim vs \case</h1>

<p>A definition of a function by pattern matching can be given either with <span class="inl-highlight"><span class="k">\elim</span></span> or with 
<span class="inl-highlight"><span class="k">\case</span></span>. These two ways are almost equivalent, but there is one small difference:
depending on whether <span class="inl-highlight">f</span> is defined via <span class="inl-highlight"><span class="k">\case</span></span> or via <span class="inl-highlight"><span class="k">\elim</span></span>,
the expression <span class="inl-highlight">f x</span> evaluates to the <span class="inl-highlight"><span class="k">\case</span></span> expression or does not evaluate 
respectively. Consider, for example, the following two definitions:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> f (x <span class="o">:</span> Nat) <span class="o">:</span> Nat <span class="o">=&gt;</span> <span class="k">\case</span> x <span class="k">\with</span> { zero <span class="o">=&gt;</span> <span class="n">0</span> <span class="o">|</span> suc n <span class="o">=&gt;</span> n }
<span class="k">\func</span> f' (x <span class="o">:</span> Nat) <span class="o">:</span> Nat <span class="o">|</span> zero <span class="o">=&gt;</span> <span class="n">0</span> <span class="o">|</span> suc n <span class="o">=&gt;</span> n</code></pre></div></div>

<p><span class="inl-highlight">f n</span> evaluates to the body of the definition, whereas the expression <span class="inl-highlight">f’ n</span>
is in normal form. The latter option makes normalized terms look nicer and for that reason is usually preferable.</p>

<h1 id="case-in-dependently-typed-languages">\case in dependently typed languages</h1>

<p>Case expressions are more subtle in dependently typed languages than in languages like Haskell. Let us
assume, for example, we want to prove that <span class="inl-highlight">p a <span class="o">=</span> not (not (p a))</span> for some predicate
<span class="inl-highlight">p <span class="o">:</span> A <span class="o">-&gt;</span> Bool</span> and <span class="inl-highlight">a <span class="o">:</span> A</span>. Of course, this statement can be proved as 
a consequence of a generalized statement <span class="inl-highlight">x <span class="o">=</span> not (not (x))</span>, and that is the right
way to do it, but we would like to show how it can be proven with <span class="inl-highlight"><span class="k">\case</span></span>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> not (b <span class="o">:</span> Bool) <span class="o">:</span> Bool
  <span class="o">|</span> true <span class="o">=&gt;</span> false
  <span class="o">|</span> false <span class="o">=&gt;</span> true

<span class="k">\func</span> foo {A <span class="o">:</span> <span class="kt">\Type</span>} (p <span class="o">:</span> A <span class="o">-&gt;</span> Bool) (a <span class="o">:</span> A) <span class="o">:</span> p a <span class="o">=</span> not (not (p a)) <span class="o">=&gt;</span>
   <span class="k">\case</span> p a <span class="k">\as</span> b <span class="k">\return</span> b <span class="o">=</span> not (not b) <span class="k">\with</span> {
    <span class="o">|</span> true <span class="o">=&gt;</span> idp 
    <span class="o">|</span> false <span class="o">=&gt;</span> idp
  }</code></pre></div></div>

<p>Here we specified explicitly the return type of the case expression by writing 
<span class="inl-highlight"><span class="k">\return</span> b <span class="o">=</span> not (not b)</span> before the keyword <span class="inl-highlight"><span class="k">\with</span></span>. We do this because
this return type of <span class="inl-highlight"><span class="k">\case</span></span> depends on the expression <span class="inl-highlight">p a</span> that we match
on. In order to describe the dependence, we introduce new bound variable <span class="inl-highlight">b</span> by
writing <span class="inl-highlight"><span class="k">\as</span> b</span> just after the expression <span class="inl-highlight">p a</span>.</p>

<p>In every clause we should return an expression, whose type is the expression obtained from the one written
after <span class="inl-highlight"><span class="k">\return</span></span> by substituting the corresponding pattern. In example above we have:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|</span> true <span class="o">=&gt;</span> idp <span class="c">-- here we should return expression of type true = not (not true)</span>
<span class="o">|</span> false <span class="o">=&gt;</span> idp <span class="c">-- and here of type false = not (not false)</span></code></pre></div></div>

<p>As we said, we could use a helper function:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> foo' {A <span class="o">:</span> <span class="kt">\Type</span>} (p <span class="o">:</span> A <span class="o">-&gt;</span> Bool) (a <span class="o">:</span> A) <span class="o">:</span> p a <span class="o">=</span> not (not (p a)) <span class="o">=&gt;</span>
  helper (p a)
  <span class="k">\where</span>
    <span class="k">\func</span> helper (b <span class="o">:</span> Bool) <span class="o">:</span> b <span class="o">=</span> not (not b) <span class="k">\elim</span> b
      <span class="o">|</span> true <span class="o">=&gt;</span> idp
      <span class="o">|</span> false <span class="o">=&gt;</span> idp</code></pre></div></div>

<h1 id="case-with-several-arguments">\case with several arguments</h1>

<p>We can pattern match on several expressions in <span class="inl-highlight"><span class="k">\case</span></span>. For example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\data</span> Ordering <span class="o">|</span> LT <span class="o">|</span> EQ <span class="o">|</span> GT

<span class="k">\func</span> compare (x y <span class="o">:</span> Nat) <span class="o">:</span> Ordering <span class="o">=&gt;</span>
  <span class="k">\case</span> x &lt; y<span class="o">,</span> y &lt; x <span class="k">\with</span> {
    <span class="o">|</span> true<span class="o">,</span> true <span class="o">=&gt;</span> EQ <span class="c">-- this will never be matched</span>
    <span class="o">|</span> true<span class="o">,</span> false <span class="o">=&gt;</span> LT
    <span class="o">|</span> false<span class="o">,</span> true <span class="o">=&gt;</span> GT
    <span class="o">|</span> false<span class="o">,</span> false <span class="o">=&gt;</span> EQ
  }</code></pre></div></div>

<h1 id="proof-of-a-fact-about-filter-via-case">Proof of a fact about filter via \case</h1>

<p>Let us consider one more example of a proof via <span class="inl-highlight"><span class="k">\case</span></span>: let us prove
that the length of a filtered list <span class="inl-highlight">filter xs</span> is at most the 
length of the original list <span class="inl-highlight">xs</span>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\data</span> Empty

<span class="k">\func</span> absurd {A <span class="o">:</span> <span class="kt">\Type</span>} (e <span class="o">:</span> Empty) <span class="o">:</span> A

<span class="k">\data</span> Unit <span class="o">|</span> unit

<span class="k">\func</span> <span class="k">\infix</span> <span class="n">4</span> &lt;= (x y <span class="o">:</span> Nat) <span class="o">:</span> <span class="kt">\Type</span>
  <span class="o">|</span> <span class="n">0</span><span class="o">,</span> <span class="u">_</span> <span class="o">=&gt;</span> Unit
  <span class="o">|</span> suc <span class="u">_</span><span class="o">,</span> <span class="n">0</span> <span class="o">=&gt;</span> Empty
  <span class="o">|</span> suc x<span class="o">,</span> suc y <span class="o">=&gt;</span> x &lt;= y

<span class="k">\func</span> length {A <span class="o">:</span> <span class="kt">\Type</span>} (xs <span class="o">:</span> List A) <span class="o">:</span> Nat
  <span class="o">|</span> nil <span class="o">=&gt;</span> <span class="n">0</span>
  <span class="o">|</span> cons <span class="u">_</span> xs <span class="o">=&gt;</span> suc (length xs)

<span class="c">-- auxiliary helper lemma</span>
<span class="k">\func</span> &lt;=-helper {x y <span class="o">:</span> Nat} (p <span class="o">:</span> x &lt;= y) <span class="o">:</span> x &lt;= suc y <span class="k">\elim</span> x<span class="o">,</span> y
  <span class="o">|</span> <span class="n">0</span><span class="o">,</span> <span class="u">_</span> <span class="o">=&gt;</span> unit
  <span class="o">|</span> suc x<span class="o">,</span> <span class="n">0</span> <span class="o">=&gt;</span> absurd p
  <span class="o">|</span> suc x<span class="o">,</span> suc y <span class="o">=&gt;</span> &lt;=-helper p

<span class="k">\func</span> filter-lem {A <span class="o">:</span> <span class="kt">\Type</span>} (p <span class="o">:</span> A <span class="o">-&gt;</span> Bool) (xs <span class="o">:</span> List A) <span class="o">:</span> length (filter p xs) &lt;= length xs <span class="k">\elim</span> xs
  <span class="o">|</span> nil <span class="o">=&gt;</span> unit
  <span class="o">|</span> cons x xs <span class="o">=&gt;</span> <span class="k">\case</span> p x <span class="k">\as</span> b <span class="k">\return</span> length (<span class="k">\case</span> b <span class="k">\with</span> { <span class="o">|</span> true <span class="o">=&gt;</span> cons x (filter p xs) <span class="o">|</span> false <span class="o">=&gt;</span> filter p xs }) &lt;= suc (length xs) <span class="k">\with</span> {
    <span class="o">|</span> true <span class="o">=&gt;</span> filter-lem p xs
    <span class="o">|</span> false <span class="o">=&gt;</span> &lt;=-helper (filter-lem p xs)
  }</code></pre></div></div>

<p class="notice--info"><strong>Exercise 2:</strong> Define <span class="inl-highlight">filter</span> via <span class="inl-highlight">if</span> not using <span class="inl-highlight"><span class="k">\case</span></span>.
Prove the lemma <span class="inl-highlight">filter-lem</span> for this version of <span class="inl-highlight">filter</span>.</p>

<h1 id="elim-in-case">\elim in \case</h1>

<p>Suppose we want to prove that <span class="inl-highlight">&amp;&amp;</span> is associative using <span class="inl-highlight"><span class="k">\case</span></span>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> <span class="k">\infixr</span> <span class="n">3</span> &amp;&amp; (x y <span class="o">:</span> Bool) <span class="o">:</span> Bool <span class="k">\elim</span> x
  <span class="o">|</span> true <span class="o">=&gt;</span> y
  <span class="o">|</span> false <span class="o">=&gt;</span> false

<span class="k">\func</span> &amp;&amp;-assoc (x y z <span class="o">:</span> Bool) <span class="o">:</span> (x &amp;&amp; y) &amp;&amp; z <span class="o">=</span> x &amp;&amp; (y &amp;&amp; z) <span class="o">=&gt;</span> <span class="k">\case</span> x <span class="k">\with</span> {
  <span class="o">|</span> true <span class="o">=&gt;</span> <span class="g">{?}</span>
  <span class="o">|</span> false <span class="o">=&gt;</span> <span class="g">{?}</span>
}</code></pre></div></div>

<p>This will not work since <span class="inl-highlight">x</span> will not be replaced with the corresponding pattern in each of the cases above.
To make this work, we need to bind <span class="inl-highlight">x</span> again and explicitly specify the result type of the <span class="inl-highlight"><span class="k">\case</span></span>-expression:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> &amp;&amp;-assoc (x y z <span class="o">:</span> Bool) <span class="o">:</span> (x &amp;&amp; y) &amp;&amp; z <span class="o">=</span> x &amp;&amp; (y &amp;&amp; z) <span class="o">=&gt;</span> <span class="k">\case</span> x <span class="k">\as</span> x' <span class="k">\return</span> (x' &amp;&amp; y) &amp;&amp; z <span class="o">=</span> x' &amp;&amp; (y &amp;&amp; z) <span class="k">\with</span> {
  <span class="o">|</span> true <span class="o">=&gt;</span> idp
  <span class="o">|</span> false <span class="o">=&gt;</span> idp
}</code></pre></div></div>

<p>This is a common pattern.
In such cases, we can use keyword <span class="inl-highlight"><span class="k">\elim</span></span> to simplify the <span class="inl-highlight"><span class="k">\case</span></span> expression.
It can be written before a variable in a <span class="inl-highlight"><span class="k">\case</span></span> expression.
Then this variable will be replaced with corresponding patterns in each of the cases in the result type.
Thus, we can rewrite the example above as follows:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> &amp;&amp;-assoc (x y z <span class="o">:</span> Bool) <span class="o">:</span> (x &amp;&amp; y) &amp;&amp; z <span class="o">=</span> x &amp;&amp; (y &amp;&amp; z) <span class="o">=&gt;</span> <span class="k">\case</span> <span class="k">\elim</span> x <span class="k">\with</span> {
  <span class="o">|</span> true <span class="o">=&gt;</span> idp
  <span class="o">|</span> false <span class="o">=&gt;</span> idp
}</code></pre></div></div>

<h1 id="matching-on-idp-in-case">Matching on idp in \case</h1>

<p>When we match on some expression <span class="inl-highlight">e</span>, the connection between this expression and the 
result of the pattern matching gets lost. For example, we cannot even prove that <span class="inl-highlight">expr</span> equals <span class="inl-highlight">pattern</span>
inside an expression of the form <span class="inl-highlight"><span class="k">\case</span> expr <span class="k">\with</span> { <span class="o">|</span> pattern <span class="o">=&gt;</span> <span class="g">{?}</span> }</span>.
Sometimes we need to remember such a connection.
In these cases we can use the following trick: double pattern matching
on the original expression <span class="inl-highlight">e</span> and on <span class="inl-highlight">idp</span> with explicitly written type depending on
<span class="inl-highlight">e</span>. Consider an example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> baz {A <span class="o">:</span> <span class="kt">\Type</span>} (B <span class="o">:</span> Bool <span class="o">-&gt;</span> <span class="kt">\Type</span>) (p <span class="o">:</span> A <span class="o">-&gt;</span> Bool) (a <span class="o">:</span> A) (pt <span class="o">:</span> B true) (pf <span class="o">:</span> B false) <span class="o">:</span> B (p a) <span class="o">=&gt;</span>
    <span class="c">-- Not only the return type can be specified explicitly, but also </span>
    <span class="c">-- the type of expressions we do matching on.</span>
    <span class="c">-- And we can use variables bounded in \as.</span>
    <span class="k">\case</span> p a <span class="k">\as</span> b<span class="o">,</span> idp <span class="o">:</span> b <span class="o">=</span> p a <span class="k">\with</span> {
      <span class="o">|</span> true<span class="o">,</span> q <span class="o">=&gt;</span> transport B q pt <span class="c">-- here q : true = p a</span>
      <span class="o">|</span> false<span class="o">,</span> q <span class="o">=&gt;</span> transport B q pf <span class="c">-- here q : false = p a</span>
    }</code></pre></div></div>

<p>And a helper version again:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> baz' {A <span class="o">:</span> <span class="kt">\Type</span>} (B <span class="o">:</span> Bool <span class="o">-&gt;</span> <span class="kt">\Type</span>) (p <span class="o">:</span> A <span class="o">-&gt;</span> Bool) (a <span class="o">:</span> A) (pt <span class="o">:</span> B true) (pf <span class="o">:</span> B false) <span class="o">:</span> B (p a) <span class="o">=&gt;</span> 
    helper B p a pt pf
           (p a) idp
  <span class="k">\where</span>
    <span class="k">\func</span> helper {A <span class="o">:</span> <span class="kt">\Type</span>} (B <span class="o">:</span> Bool <span class="o">-&gt;</span> <span class="kt">\Type</span>) (p <span class="o">:</span> A <span class="o">-&gt;</span> Bool) (a <span class="o">:</span> A) (pt <span class="o">:</span> B true) (pf <span class="o">:</span> B false)
                (b <span class="o">:</span> Bool) (q <span class="o">:</span> b <span class="o">=</span> p a) <span class="o">:</span> B (p a) <span class="k">\elim</span> b
      <span class="o">|</span> true <span class="o">=&gt;</span> transport B q pt <span class="c">-- here q : true = p a</span>
      <span class="o">|</span> false <span class="o">=&gt;</span> transport B q pf <span class="c">-- here q : false = p a</span></code></pre></div></div>

<p class="notice--info"><strong>Exercise 3:</strong> Prove that, for every function <span class="inl-highlight">f <span class="o">:</span> Bool <span class="o">-&gt;</span> Bool</span> and every <span class="inl-highlight">x <span class="o">:</span> Bool</span>, it is true that <span class="inl-highlight">f (f (f x)) <span class="o">=</span> f x</span></p>

<h1 id="one-more-example-of-case">One more example of \case</h1>

<p>Let us consider one more example, demonstrating what we have just discussed:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> bar {A <span class="o">:</span> <span class="kt">\Type</span>} (p q <span class="o">:</span> A <span class="o">-&gt;</span> Bool) (a <span class="o">:</span> A) (s <span class="o">:</span> q a <span class="o">=</span> not (p a))
  <span class="o">:</span> not (q a) <span class="o">=</span> p a <span class="o">=&gt;</span>
  <span class="k">\case</span> p a <span class="k">\as</span> x<span class="o">,</span> q a <span class="k">\as</span> y<span class="o">,</span> s <span class="o">:</span> y <span class="o">=</span> not x <span class="k">\return</span> not y <span class="o">=</span> x <span class="k">\with</span> {
    <span class="o">|</span> true<span class="o">,</span> true<span class="o">,</span> s' <span class="o">=&gt;</span> inv s'
    <span class="o">|</span> true<span class="o">,</span> false<span class="o">,</span> <span class="u">_</span> <span class="o">=&gt;</span> idp
    <span class="o">|</span> false<span class="o">,</span> true<span class="o">,</span> <span class="u">_</span> <span class="o">=&gt;</span> idp
    <span class="o">|</span> false<span class="o">,</span> false<span class="o">,</span> s' <span class="o">=&gt;</span> inv s'
  }

<span class="c">-- helper version</span>
<span class="k">\func</span> bar' {A <span class="o">:</span> <span class="kt">\Type</span>} (p q <span class="o">:</span> A <span class="o">-&gt;</span> Bool) (a <span class="o">:</span> A) (s <span class="o">:</span> q a <span class="o">=</span> not (p a))
  <span class="o">:</span> not (q a) <span class="o">=</span> p a <span class="o">=&gt;</span> helper (p a) (q a) s
  <span class="k">\where</span>
    <span class="k">\func</span> helper (x y <span class="o">:</span> Bool) (s <span class="o">:</span> y <span class="o">=</span> not x) <span class="o">:</span> not y <span class="o">=</span> x <span class="k">\elim</span> x<span class="o">,</span> y
      <span class="o">|</span> true<span class="o">,</span> true <span class="o">=&gt;</span> inv s
      <span class="o">|</span> true<span class="o">,</span> false <span class="o">=&gt;</span> idp
      <span class="o">|</span> false<span class="o">,</span> true <span class="o">=&gt;</span> idp
      <span class="o">|</span> false<span class="o">,</span> false <span class="o">=&gt;</span> inv s</code></pre></div></div>

<h1 id="views">Views</h1>

<p>Views – is a techique that allows to define some kind of custom pattern matching for data types.
For example, <span class="inl-highlight">Nat</span> has constructors <span class="inl-highlight">zero</span> and <span class="inl-highlight">suc</span>
and by default we pattern match on them whenever we define a function from <span class="inl-highlight">Nat</span>.
But we can also define a custom pattern matching for <span class="inl-highlight">Nat</span> as if <span class="inl-highlight">Nat</span>
had constructors, say, <span class="inl-highlight">even</span> and <span class="inl-highlight">odd</span>.</p>

<p>Let us define a data type parameterized by the data type we are defining custom pattern matching for
(<span class="inl-highlight">Nat</span> in our example). The constructors of this data type will correspond to
the constructors that we want to use for our custom pattern matching (<span class="inl-highlight">even</span> and 
<span class="inl-highlight">odd</span> in our example). Each constructor should have a parameter of the form <span class="inl-highlight">n <span class="o">=</span> expr</span>,
where <span class="inl-highlight">expr</span> represents the custom pattern. In our example we have the following:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\data</span> Parity (n <span class="o">:</span> Nat)
  <span class="o">|</span> even (k <span class="o">:</span> Nat) (p <span class="o">:</span> n <span class="o">=</span> <span class="n">2</span> <span class="o">*</span> k)
  <span class="o">|</span> odd (k <span class="o">:</span> Nat) (p <span class="o">:</span> n <span class="o">=</span> <span class="n">2</span> <span class="o">*</span> k <span class="o">+</span> <span class="n">1</span>)</code></pre></div></div>

<p>Next, we define a function that converts elements of <span class="inl-highlight">Nat</span> to elements of <span class="inl-highlight">Parity</span>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> parity (n <span class="o">:</span> Nat) <span class="o">:</span> Parity n
  <span class="o">|</span> <span class="n">0</span> <span class="o">=&gt;</span> even <span class="n">0</span> idp
  <span class="o">|</span> suc n <span class="o">=&gt;</span> <span class="k">\case</span> parity n <span class="k">\with</span> {
    <span class="o">|</span> even k p <span class="o">=&gt;</span> odd k (pmap suc p)
    <span class="o">|</span> odd k p <span class="o">=&gt;</span> even (suc k) (pmap suc p)
  }</code></pre></div></div>

<p>Now, in order to pattern match on <span class="inl-highlight">n <span class="o">:</span> Nat</span> we should invoke <span class="inl-highlight"><span class="k">\case</span></span>
on <span class="inl-highlight">parity n</span>. For example, let us define division by 2:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> div2 (n <span class="o">:</span> Nat) <span class="o">:</span> Nat <span class="o">=&gt;</span> <span class="k">\case</span> parity n <span class="k">\with</span> {
  <span class="o">|</span> even k <span class="u">_</span> <span class="o">=&gt;</span> k
  <span class="o">|</span> odd k <span class="u">_</span> <span class="o">=&gt;</span> k
  }</code></pre></div></div>

<p class="notice--info"><strong>Exercise 4:</strong> Define the view, which represents a natural number as a pair of the quotient and the remainder of
division by a positive <span class="inl-highlight">m</span>. Implement the division function.</p>

<h1 id="decidable-predicates">Decidable predicates</h1>

<p>Here we will discuss predicates in propositions-as-types logic, that is functions <span class="inl-highlight">P <span class="o">:</span> A <span class="o">-&gt;</span> <span class="kt">\Type</span></span>.
A predicate is called <em>decidable</em> if there is a proof that for all <span class="inl-highlight">x <span class="o">:</span> A</span> either <span class="inl-highlight">P x</span>
or not <span class="inl-highlight">P x</span>. We can write the statement <span class="inl-highlight">DecPred P</span> saying that <span class="inl-highlight">P</span>
is decidable as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\data</span> Decide (A <span class="o">:</span> <span class="kt">\Type</span>)
  <span class="o">|</span> yes A
  <span class="o">|</span> no (A <span class="o">-&gt;</span> Empty)

<span class="k">\func</span> DecPred {A <span class="o">:</span> <span class="kt">\Type</span>} (P <span class="o">:</span> A <span class="o">-&gt;</span> <span class="kt">\Type</span>) <span class="o">=&gt;</span> <span class="k">\Pi</span> (a <span class="o">:</span> A) <span class="o">-&gt;</span> Decide (P a)</code></pre></div></div>

<p>This notion of decidability is related to decidability in computability theory:
if a predicate is decidable in this sense, then there exists an algorithm that for every <span class="inl-highlight">x <span class="o">:</span> A</span>
decides whether <span class="inl-highlight">P x</span> or not <span class="inl-highlight">P x</span>.</p>

<p>In particular, there exist undecidable predicates.
For example, we can define the following predicate <span class="inl-highlight">P <span class="o">:</span> Nat <span class="o">-&gt;</span> <span class="kt">\Type</span></span>: <span class="inl-highlight">P n</span> encodes
the statement “Turing machine with number n halts at the input n”. A simpler example – the predicate on pairs of
functions <span class="inl-highlight">Nat <span class="o">-&gt;</span> Nat</span>, saying that they are equal.</p>

<p>An example of decidable predicate:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> suc/=0 {n <span class="o">:</span> Nat} (p <span class="o">:</span> suc n <span class="o">=</span> <span class="n">0</span>) <span class="o">:</span> Empty <span class="o">=&gt;</span> transport (<span class="k">\lam</span> n <span class="o">=&gt;</span> <span class="k">\case</span> n <span class="k">\with</span> { <span class="o">|</span> <span class="n">0</span> <span class="o">=&gt;</span> Empty <span class="o">|</span> suc <span class="u">_</span> <span class="o">=&gt;</span> Unit }) p unit
 
<span class="c">-- the predicate \lam n =&gt; n = 0 is decidable</span>
<span class="k">\func</span> decide0 <span class="o">:</span> DecPred (<span class="k">\lam</span> (n <span class="o">:</span> Nat) <span class="o">=&gt;</span> n <span class="o">=</span> <span class="n">0</span>) <span class="o">=&gt;</span> <span class="k">\lam</span> n <span class="o">=&gt;</span>
  <span class="k">\case</span> n <span class="k">\as</span> n' <span class="k">\return</span> Decide (n' <span class="o">=</span> <span class="n">0</span>) <span class="k">\with</span> {
    <span class="o">|</span> <span class="n">0</span> <span class="o">=&gt;</span> yes idp
    <span class="o">|</span> suc <span class="u">_</span> <span class="o">=&gt;</span> no suc/=0
  }</code></pre></div></div>

<p>The above properties of decidability hold as long as our logic is intuitionistic. If we have the Law of Excluded
Middle, then all predicates are decidable, and, in fact, the opposite implication is also true.</p>

<p class="notice--info"><strong>Exercise 5:</strong> Prove that the predicate ‘isEven’ is decidable.</p>

<h1 id="decidable-equality">Decidable equality</h1>

<p>Let us consider the predicate <span class="inl-highlight">DecEq A</span>, saying that type <span class="inl-highlight">A</span> has decidable equality on it:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> DecEq (A <span class="o">:</span> <span class="kt">\Type</span>) <span class="o">=&gt;</span> <span class="k">\Pi</span> (a a' <span class="o">:</span> A) <span class="o">-&gt;</span> Decide (a <span class="o">=</span> a')</code></pre></div></div>

<p>We can define a typeclass analogous to Eq in Haskell, but with a proof of decidability of equality instead of a function 
<span class="inl-highlight"><span class="o">==</span> <span class="o">:</span> A <span class="o">-&gt;</span> A <span class="o">-&gt;</span> Bool</span>. This is better since in Haskell <span class="inl-highlight"><span class="o">==</span></span> can be absolutely any function,
not necessarily having anything to do with equality.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\class</span> Eq (A <span class="o">:</span> <span class="kt">\Type</span>) {
  <span class="o">|</span> decideEq <span class="o">:</span> DecEq A
  <span class="c">-- Functions declared inside a class have instance of</span>
  <span class="c">-- the class as their first implicit parameter.</span>
  <span class="k">\func</span> <span class="k">\infix</span> <span class="n">4</span> <span class="o">==</span> (a a' <span class="o">:</span> A) <span class="o">:</span> Bool <span class="o">=&gt;</span> <span class="k">\case</span> decideEq a a' <span class="k">\with</span> {
    <span class="o">|</span> yes <span class="u">_</span> <span class="o">=&gt;</span> true
    <span class="o">|</span> no <span class="u">_</span> <span class="o">=&gt;</span> false
  }
} <span class="k">\where</span> {
  <span class="c">-- Function == is equivalent to =='.</span>
  <span class="k">\func</span> <span class="k">\infix</span> <span class="n">4</span> <span class="o">=='</span> {e <span class="o">:</span> Eq} (a a' <span class="o">:</span> e.A) <span class="o">:</span> Bool <span class="o">=&gt;</span> <span class="k">\case</span> e.decideEq a a' <span class="k">\with</span> {
    <span class="o">|</span> yes <span class="u">_</span> <span class="o">=&gt;</span> true
    <span class="o">|</span> no <span class="u">_</span> <span class="o">=&gt;</span> false
  }
}</code></pre></div></div>

<p>Let us define an instance for the type of natural numbers:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> pred (n <span class="o">:</span> Nat) <span class="o">:</span> Nat
  <span class="o">|</span> <span class="n">0</span> <span class="o">=&gt;</span> <span class="n">0</span>
  <span class="o">|</span> suc n <span class="o">=&gt;</span> n

<span class="k">\instance</span> NatEq <span class="o">:</span> Eq Nat
  <span class="o">|</span> decideEq <span class="o">=&gt;</span> decideEq
  <span class="k">\where</span>
    <span class="k">\func</span> decideEq (x y <span class="o">:</span> Nat) <span class="o">:</span> Decide (x <span class="o">=</span> y)
      <span class="o">|</span> <span class="n">0</span><span class="o">,</span> <span class="n">0</span> <span class="o">=&gt;</span> yes idp
      <span class="o">|</span> <span class="n">0</span><span class="o">,</span> suc y <span class="o">=&gt;</span> no (<span class="k">\lam</span> p <span class="o">=&gt;</span> suc/=0 (inv p))
      <span class="o">|</span> suc x<span class="o">,</span> <span class="n">0</span> <span class="o">=&gt;</span> no suc/=0
      <span class="o">|</span> suc x<span class="o">,</span> suc y <span class="o">=&gt;</span> <span class="k">\case</span> decideEq x y <span class="k">\with</span> {
        <span class="o">|</span> yes p <span class="o">=&gt;</span> yes (pmap suc p)
        <span class="o">|</span> no c <span class="o">=&gt;</span> no (<span class="k">\lam</span> p <span class="o">=&gt;</span> c (pmap pred p))
      }

<span class="k">\func</span> test1 <span class="o">:</span> (<span class="n">0</span> <span class="o">==</span> <span class="n">0</span>) <span class="o">=</span> true <span class="o">=&gt;</span> idp
<span class="k">\func</span> test2 <span class="o">:</span> (<span class="n">0</span> <span class="o">==</span> <span class="n">1</span>) <span class="o">=</span> false <span class="o">=&gt;</span> idp</code></pre></div></div>

<p class="notice--info"><strong>Exercise 6:</strong> Prove that if equality of elements of a type <span class="inl-highlight">A</span> is decidable, then eqiality of elements if <span class="inl-highlight">List A</span> is
also decidable.</p>

<p class="notice--info"><strong>Exercise 7:</strong> Prove that if equality of elements of a type <span class="inl-highlight">A</span> is decidable, then every list of elements of <span class="inl-highlight">A</span> is either empty,
consists of repetitions of one element or there exist two different elements in <span class="inl-highlight">A</span>.</p>

<h1 id="decidable-predicates-and-functions-a---bool">Decidable predicates and functions A -&gt; Bool</h1>

<p>Decidable predicates <span class="inl-highlight">A <span class="o">-&gt;</span> <span class="kt">\Type</span></span> correspond precisely to functions <span class="inl-highlight">A <span class="o">-&gt;</span> Bool</span>.
Let us define the conversion functions:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> FromBoolToDec {A <span class="o">:</span> <span class="kt">\Type</span>} (p <span class="o">:</span> A <span class="o">-&gt;</span> Bool) <span class="o">:</span> <span class="k">\Sigma</span> (P <span class="o">:</span> A <span class="o">-&gt;</span> <span class="kt">\Type</span>) (DecPred P)
  <span class="o">=&gt;</span> (<span class="k">\lam</span> a <span class="o">=&gt;</span> T (p a)<span class="o">,</span> <span class="k">\lam</span> a <span class="o">=&gt;</span> <span class="k">\case</span> p a <span class="k">\as</span> b <span class="k">\return</span> Decide (T b) <span class="k">\with</span> {
    <span class="o">|</span> true <span class="o">=&gt;</span> yes tt
    <span class="o">|</span> false <span class="o">=&gt;</span> no T-absurd
  })

<span class="k">\func</span> FromDecToBool {A <span class="o">:</span> <span class="kt">\Type</span>} (P <span class="o">:</span> <span class="k">\Sigma</span> (P <span class="o">:</span> A <span class="o">-&gt;</span> <span class="kt">\Type</span>) (DecPred P)) <span class="o">:</span> A <span class="o">-&gt;</span> Bool
  <span class="o">=&gt;</span> <span class="k">\lam</span> a <span class="o">=&gt;</span> <span class="k">\case</span> P.<span class="n">2</span> a <span class="k">\with</span> {
    <span class="o">|</span> yes <span class="u">_</span> <span class="o">=&gt;</span> true
    <span class="o">|</span> no <span class="u">_</span> <span class="o">=&gt;</span> false
  }</code></pre></div></div>

<p class="notice--info"><strong>Exercise 8:</strong> Prove that the functions ‘FromBoolToDec’ and ‘FromDecToBool’ are inverse to each other.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\func</span> bdb {A <span class="o">:</span> <span class="kt">\Type</span>} (p <span class="o">:</span> A <span class="o">-&gt;</span> Bool) <span class="o">:</span> FromDecToBool (FromBoolToDec p) <span class="o">=</span> p <span class="o">=&gt;</span> <span class="g">{?}</span>

<span class="c">-- We cannot prove that 'FromBoolToDec (FromDecToBool P) = P', but we can prove a weaker statement:</span>
<span class="c">-- these predicates are logically equivalent.</span>

<span class="c">-- Equivalence of predicates</span>
<span class="k">\func</span> <span class="k">\infix</span> <span class="n">4</span> &lt;-&gt; {A <span class="o">:</span> <span class="kt">\Type</span>} (P Q <span class="o">:</span> A <span class="o">-&gt;</span> <span class="kt">\Type</span>) <span class="o">=&gt;</span> <span class="k">\Pi</span> (x <span class="o">:</span> A) <span class="o">-&gt;</span> <span class="k">\Sigma</span> (P x <span class="o">-&gt;</span> Q x) (Q x <span class="o">-&gt;</span> P x)

<span class="k">\func</span> dbd {A <span class="o">:</span> <span class="kt">\Type</span>} (P <span class="o">:</span> <span class="k">\Sigma</span> (P <span class="o">:</span> A <span class="o">-&gt;</span> <span class="kt">\Type</span>) (DecPred P)) <span class="o">:</span> (FromBoolToDec (FromDecToBool P)).<span class="n">1</span> &lt;-&gt; P.<span class="n">1</span> <span class="o">=&gt;</span> <span class="g">{?}</span></code></pre></div></div>


        
      </section>

      <footer class="page__meta">
        
        


        
      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://github.com/JetBrains/Arend" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://twitter.com/ArendLang" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i> Twitter</a></li>
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2020 Arend. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
